[{"content":"总所周知学习 Java 逃不开对各类设计模式的理解运用。今天千里冰封介绍了一个全新的设计模式——\u0026ldquo;Tagless Final\u0026rdquo; Style, 它可以用 trait 在 Rust 中模拟子类型。\n第一步实现目标 实现一个 expr 范型方法，可以根据类型执行。如下方代码，可以已 u32 或者 String 的类型返回\nfn main() { fn expr\u0026lt;T: Expr\u0026gt;() -\u0026gt; T { Expr::add( Expr::div(Expr::lit(100), Expr::lit(10)), Expr::sub(Expr::lit(223), Expr::lit(23)), ) } println!(\u0026#34;{}\u0026#34;, expr::\u0026lt;u32\u0026gt;()); println!(\u0026#34;{}\u0026#34;, expr::\u0026lt;String\u0026gt;()); } output:\n/Users/edward/.cargo/bin/cargo run --color=always --package tagless --bin tagless Compiling tagless v0.1.0 (/Users/edward/github/SASUKE40/tagless) Finished dev [unoptimized + debuginfo] target(s) in 0.39s Running `target/debug/tagless` 210 ((100 / 10) + (223 - 23)) 基础的 Expr trait 定义 这个最基础的 trait 是外部引入，不能更改的。\npub(crate) trait Expr { fn lit(i: u32) -\u0026gt; Self; fn add(lhs: Self, rhs: Self) -\u0026gt; Self; fn sub(lhs: Self, rhs: Self) -\u0026gt; Self; fn mul(lhs: Self, rhs: Self) -\u0026gt; Self; fn div(lhs: Self, rhs: Self) -\u0026gt; Self; } 实现 String 和 u32 的 impl impl Expr for u32 { fn lit(i: u32) -\u0026gt; Self { i } fn add(lhs: Self, rhs: Self) -\u0026gt; Self { lhs + rhs } fn sub(lhs: Self, rhs: Self) -\u0026gt; Self { lhs - rhs } fn mul(lhs: Self, rhs: Self) -\u0026gt; Self { lhs * rhs } fn div(lhs: Self, rhs: Self) -\u0026gt; Self { lhs / rhs } } impl Expr for String { fn lit(i: u32) -\u0026gt; Self { i.to_string() } fn add(lhs: Self, rhs: Self) -\u0026gt; Self { format!(\u0026#34;({} + {})\u0026#34;, lhs, rhs) } fn sub(lhs: Self, rhs: Self) -\u0026gt; Self { format!(\u0026#34;({} - {})\u0026#34;, lhs, rhs) } fn mul(lhs: Self, rhs: Self) -\u0026gt; Self { format!(\u0026#34;({} * {})\u0026#34;, lhs, rhs) } fn div(lhs: Self, rhs: Self) -\u0026gt; Self { format!(\u0026#34;({} / {})\u0026#34;, lhs, rhs) } } 以上的内容都单独抽出放入到 expr.rs 中。\n给 expr 增加 exp 方法 因为 Expr trait 不可被更改，所以新增一个 trait 的 TypeParamBounds[^https://doc.rust-lang.org/reference/items/traits.html]: Rust traits\nSyntax Trait : unsafe? trait IDENTIFIER Generics? ( : TypeParamBounds? )? WhereClause? { TraitItem* } 定义一个新的 ExprWithExp trait，并实现 u32 和 String 类型的 exp 方法：\ntrait ExprWithExp: Expr { fn exp(lhs: Self, rhs: Self) -\u0026gt; Self; } impl ExprWithExp for u32 { fn exp(lhs: Self, rhs: Self) -\u0026gt; Self { lhs.pow(rhs) } } impl ExprWithExp for String { fn exp(lhs: Self, rhs: Self) -\u0026gt; Self { format!(\u0026#34;({} ^ {})\u0026#34;, lhs, rhs) } } 这样就可以给 u32 和 String 拓展出 exp 方法\nfn main() { // snippet fn expr2\u0026lt;T: ExprWithExp\u0026gt;() -\u0026gt; T { ExprWithExp::exp(expr(), Expr::lit(2)) } println!(\u0026#34;{}\u0026#34;, expr2::\u0026lt;u32\u0026gt;()); println!(\u0026#34;{}\u0026#34;, expr2::\u0026lt;String\u0026gt;()); } output:\n/Users/edward/.cargo/bin/cargo run --color=always --package tagless --bin tagless Compiling tagless v0.1.0 (/Users/edward/github/SASUKE40/tagless) Finished dev [unoptimized + debuginfo] target(s) in 0.56s Running `target/debug/tagless` 210 ((100 / 10) + (223 - 23)) 44100 (((100 / 10) + (223 - 23)) ^ 2) ","date":"2020-07-18T00:00:00Z","image":"https://edward40.com/p/tagless-final-in-rust/rust_programming_crab_sea_hu_fb43f6b6e285abb5.png","permalink":"https://edward40.com/p/tagless-final-in-rust/","title":"Tagless Final in Rust"},{"content":"前言 最近在 React Europe 2020 Conference 上， facebook 内部释出一个状态管理库 Recoil\n通过官方的宣传以及初步的使用，Recoil 在处理 shared state 上比较方便，也能做到最小度的更新来提升复杂 App 的性能。不过有趣的是，对 Recoil 的 atom selector 这些 API 设计而言，其实就是早在 47 年提出的 Actor Model，可谓是前端状态管理的文艺复兴。\nActor Model 部分 什么是 Actor Model Actor 模型(Actor model)首先是由 Carl Hewitt 在 1973 定义， 由 Erlang OTP(Open Telecom Platform) 推广，其消息传递更加符合面向对象的原始意图。Actors 属于并发组件模型，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。\n流行语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors 使用消息模型，每个 Actors 在同一时间处理最多一个消息，可以发送消息给其他 Actors，保证了单独写原则。从而巧妙避免了多线程写争夺。\nActor Model 主要有几个特点：\n轻量：Actor 是系统内的一个基础单位，每个 Actor 只负责自己的工作 没有 Shared State：每个 Actor 各自管理自己的 state，跑在各自的 thread 上，不共享内存和 state 通过消息传递：每个 Actor 有一个消息队列，类似 MailBox / Queue，接受到的消息会在此队列等待依次执行 谁使用 Actor Model Erlang Akka Vert.x Actix \u0026hellip; Recoil 部分 Recoil 产生背景 前端的应用越来越复杂，诸如常见的 Web 监控面板，包含各类的性能数据、节点信息、分类聚合用来进行应用分析。可以想象得到面板中包含各类的交互行为，编辑、删除、添加、将一个数据源绑定多个面板等等。除此之外，还需要对数据持久化，这样就能把 url 分享给其他人，并要确保被分享的人看到的是一致的。\n因此开发过程中要尽量做到页面最小化更新达到高性能的目的，需要对数据流的操作更加精细。\n![](Recoil at React Europe 2020 00-00-12 .jpg)\n面对这样的挑战，一般会想到用一些状态管理的函数或者库，如 React 内置的 state 管理，或者 Redux。\nRecoil 想通过一个不一样的方式来解决这些问题，主要分为 3 个方面：\nFlexible shared state: 在 react tree 任意的地方都能灵活共享 state，并保持高性能 Derived data and queries: 高效可靠地根据变化的 state 进行计算 App-wide state observation: time travel debugging, 支持 undo, 日志持久化 ##Recoil 主要设计\nShared state 有一个应用基于这样一个场景，将 List 中更新一个节点，然后对应 Canvas 中的节点也更新\n![](Recoil at React Europe 2020 00-04-55 .png)\n第 1 种方式 把 state 传到公共的父节点转发给 canvas 子节点，这样显然会全量 re-render\n第 2 种方式 给父节点加 Provider 在子节点加 Consumer，不过每多加一个 item 就要多一层 Provider\n![](Recoil at React Europe 2020 00-06-43 .png)\n第 3 种方式 在 react tree 上创建另一个正交的 tree，把每片 item 的 state 抽出来。每个 component 都有对应单独的一片 state，当数据更新的时候对应的组件也会更新。Recoil 把 这每一片的数据称为 Atom，Atom 是可订阅可变的 state 单元。\n![](Recoil at React Europe 2020 00-07-24 .png)\n配合 useRecoilState 可以使用这些 Atom，实践上对多个 item 的 Atom 可以用 memorize 进行优化，具体可以在官方文档查看，这里不赘述。\nDerived Data 有这么一个场景需要根据多个 Item Box 计算 Bounding Box\n如果你是 Vue 的爱好者，你可能想到了计算属性。Derived Data 确实有 computed props 的味道，具体思路是选取多个 Atom 进行计算，然后返回一个新的 state。因此在 Recoil 中设计了 select 这样的 API 来选取多个 Atom 进行计算。\n![](Recoil at React Europe 2020 00-14-53 .png)\nselect 的设计和 Proxy 挺像的，属性上有 get 进行读取，有 set 进行设置，函数内部又有 get， set 操作 state\nimport { atom, selector, useRecoilState } from \u0026#39;recoil\u0026#39; const tempFahrenheit = atom({ key: \u0026#39;tempFahrenheit\u0026#39;, default: 32 }) const tempCelcius = selector({ key: \u0026#39;tempCelcius\u0026#39;, get: ({ get }) =\u0026gt; ((get(tempFahrenheit) - 32) * 5) / 9, set: ({ set }, newValue) =\u0026gt; set(tempFahrenheit, (newValue * 9) / 5 + 32) }) App-wide observation 这个场景下需要把 url 分享给其他人，别人打开相同的链接也能看到一样的页面。\n那么就需要 observe Atom 的变更，Recoil 使用 useTransactionObservation 进行订阅\nuseTransactionObservation(({atomValues,modifiedAtoms,...} =\u0026gt; {})) 另一方面，打开链接的时候也需要对输入的数据进行校验\nconst counter = atom({ key: \u0026#39;myCounter\u0026#39;, default: 0, validator: (untrustedInput), metadata: ... }) ##Recoil 后续\n目前 Recoil 还属于实验阶段，不过能确定的是 Recoil 会兼容 React Concurrent Mode\nActor Model \u0026amp; Recoil 联系 通过前面提及 Recoil 的设计，可以发现两者的理念是相似的。\n在实现的细节中 Recoil 维护了新的队列，并通过订阅、派发的机制完成消息的传递及组件的更新。\n// Fire or enqueue callbacks to rerender components that are subscribed to // nodes affected by the updatedNodes function fireNodeSubscriptions( store: Store, updatedNodes: $ReadOnlySet\u0026lt;NodeKey\u0026gt;, when: \u0026#39;enqueue\u0026#39; | \u0026#39;now\u0026#39; ) { /* This is called in two conditions: When an atom is set (with \u0026#39;enqueue\u0026#39;) and when an async selector resolves (with \u0026#39;now\u0026#39;). When an atom is set, we want to use the latest dependencies that may have become dependencies due to earlier changes in a batch. But if an async selector happens to resolve during a batch, it should use the currently rendered output, and then the end of the batch will trigger any further subscriptions due to new deps in the new state. */ const state = when === \u0026#39;enqueue\u0026#39; ? store.getState().nextTree ?? store.getState().currentTree : store.getState().currentTree const dependentNodes = getDownstreamNodes(state, updatedNodes) for (const key of dependentNodes) { ;(state.nodeToComponentSubscriptions.get(key) ?? []).forEach( ([debugName, cb]) =\u0026gt; { when === \u0026#39;enqueue\u0026#39; ? store.getState().queuedComponentCallbacks.push(cb) : cb(state) } ) } // Wake all suspended components so the right one(s) can try to re-render. // We need to wake up components not just when some asynchronous selector // resolved (when === \u0026#39;now\u0026#39;), but also when changing synchronous values because // they may cause a selector to change from asynchronous to synchronous, in // which case there would be no follow-up asynchronous resolution to wake us up. // TODO OPTIMIZATION Only wake up related downstream components Tracing.trace( \u0026#39;value became available, waking components\u0026#39;, Array.from(updatedNodes).join(\u0026#39;, \u0026#39;), () =\u0026gt; { const resolvers = store.getState().suspendedComponentResolvers resolvers.forEach(r =\u0026gt; r()) resolvers.clear() } ) } 其实 Recoil 不是 Actor Model 在前端的首次实践，2 年前 PolymerLabs 就有 actor-helpers 以及 actor-boilerplate 相关的实践。不过在 React 强大的生态以及 React Hooks 的加持之下，用 Sync 的方式做到异步 state 管理和共享，同时保持交互流程、高性能的 Recoil 算是补充了一个不错的方案。\n补充 Recoil 刚刚释出实验版本，我想正好可以在不断更改的过程中了解前端 Actor Model 的实现方式步骤。\n另外，其实不少人批评前端的发展就是到处借鉴，没有新的事物，像是 WPF 就有很多前端可以借鉴的地方（确实也如此）。\n不过在我看来，放到一个比较长的时期里，前端慢慢吸收各类后端、客户端的设计思想才产生“新”事物是很正常的发展进程。包括经常被提到的 Vue 和 React 孰优孰劣之争，Node.js 不堪大用等等话题，其实都是历史发展及其技术定位所致。可能对其他领域的看来是不新鲜，但对前端而言是语言发展（残疾而缝合的 JavaScript）、生态繁荣才有可能繁衍出这些对前端而言的新事物。\n","date":"2020-05-16T00:00:00Z","image":"https://edward40.com/p/recoil-a-state-management-system-for-react/Recoil%20at%20React%20Europe%202020%2000-07-24%20_hu_c0ae89147db96f70.png","permalink":"https://edward40.com/p/recoil-a-state-management-system-for-react/","title":"Recoil 一个基于 actor 模型的 React 状态管理库"},{"content":"引言 最近 Vue 3.0 发布了 Beta 版本，其中最引人注意的就是其 Composition API。而这个设计近期经常被拿来和 React Hooks 进行比较，以下是两个代码片段：\n// React function Component(props) { const [a, setA] = useState(0) return \u0026lt;a onClick={() =\u0026gt; setA(x =\u0026gt; x + 1)}\u0026gt;{a}\u0026lt;/a\u0026gt; } // Vue 3 composition API function Component(props) { const a = ref(0) const setA = () =\u0026gt; a.value++ return \u0026lt;a onClick={setA}\u0026gt;{a}\u0026lt;/a\u0026gt; } 我们可以看到两者的心智模型非常不同，React 编程范式更接近于纯函数，Vue 则采取了 Reactivity 的模式。\nReact Hooks 的心智负担 React Hooks 是在 2018 年 10 月 React Conf 的时候正式向广大开发者进行宣传，在当时看到 Dan Abramov 演讲以及现场使用 React Hooks 重构 Class Component 的时候简直惊为天人，那一刻我深深被 Function Programming 所着迷。 然而，直到如今一年半开发者各种实践，发现 React Hooks 并没有想象中的那么美好。你现在可以在知乎、掘金等各类平台上搜寻到大量的《React Hooks 最佳实践》，这不禁让人深思：React Hooks 怎么没那么美好了？\nReact Hooks 开发经常提及的一些问题我列举几个：\n我该使用单个 state 变量还是多个 state 变量？ deps 依赖过多，导致 Hooks 难以维护？ 该不该使用 useMemo？ 然后基于这些问题的最佳实践，人们又总结出：\n将完全不相关的 state 拆分为多组 state。 如果某些 state 是相互关联的，或者需要一起发生改变，就可以把它们合并为一组 state。 依赖数组依赖的值最好不要超过 3 个，否则会导致代码会难以维护。 如果发现依赖数组依赖的值过多，我们应该采取一些方法来减少它。 去掉不必要的依赖。 将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组。 通过合并相关的 state，将多个依赖值聚合为一个。 通过 setState 回调函数获取最新的 state，以减少外部依赖。 通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径。 应该使用 useMemo 的场景： 保持引用相等 成本很高的计算 无需使用 useMemo 的场景： 如果返回的值是原始值： string, boolean, null, undefined, number, symbol（不包括动态声明的 Symbol），一般不需要使用 useMemo。 仅在组件内部用到的 object、array、函数等（没有作为 props 传递给子组件），且没有用到其他 Hook 的依赖数组中，一般不需要使用 useMemo。 Hooks、Render Props 和高阶组件都有各自的使用场景，具体使用哪一种要看实际情况。 若 Hook 类型相同，且依赖数组一致时，应该合并成一个 Hook。 自定义 Hooks 的返回值可以使用 Tuple 类型，更易于在外部重命名。如果返回的值过多，则不建议使用。 ref 不要直接暴露给外部使用，而是提供一个修改值的方法。 在使用 useMemo 或者 useCallback 时，可以借助 ref 或者 setState callback，确保返回的函数只创建一次。也就是说，函数不会根据依赖数组的变化而二次创建。 React Hooks 给人一种美丽的错觉，Function Component 可以非常简单，但长期开发下才逐渐暴露出函数式编程在 JavaScript 中的困境。 对这个问题大家在思考，而 Vue 3.0 也在思考如何从 React Hooks 上取其精华去其糟粕。我们可以在 Vue RFC 中看到最初的 Class API 到 Function-based Component API 取其 FP 的精华，再到被修订为 Composition API 采用 Reactivity 的过程。\n这种改变和 JavaScript 这门语言本身的编程范式离不开，主要还是围绕一等公民函数、动态类型这两点。\nVue Composition API 是否美好 Vue 一直被人所称道的就是其开发简便，这也是隐式依赖跟踪带来的便利。然而成也萧何败也萧何，Vue 诟病的一点就是闭包对象的不可预测性，例如 this。\n在 Vue Composition API 中，我发现官方对 Ref 和 Reactive 给出了最佳实践。可能这里就有所谓的幻灭存在，就像当年很多人不听 React 官方最佳实践，在 componentWillMount 里获取数据一样。\nRef vs. Reactive 章节中有如下的对比：\n// style 1: separate variables let x = 0 let y = 0 function updatePosition(e) { x = e.pageX y = e.pageY } // --- compared to --- // style 2: single object const pos = { x: 0, y: 0 } function updatePosition(e) { pos.x = e.pageX pos.y = e.pageY } 那么依赖跟踪的迷惑就此开始，因为当你对已经 reactive 的对象进行解构赋值或者赋给新值的时候，依赖跟踪就失效了。官方对这个的态度比较模糊：\n在现阶段，我们认为在 ref vs reactive 上实施最佳做法为时尚早。我们建议您从上面的两个选项中选择与您的心智模型相符的方式。我们将收集实开发场景下的用户真反馈，并最终提供有关此主题的更明确的指导。\n对比两者 Vue Composition API：闭包变量、响应式的依赖追踪 React Hooks: 纯函数、无副作用 其实没有好坏之分，在 JavaScript 这种编程范式模棱两可的语言中，你既可以写函数，但又不能不让改引用变量（像 cpp 的 const\u0026amp; 一般），你又可以面向对象编程（像 Java 一样疯狂反射，咻咻咻）。\n其实语言、框架没有优劣，主要看使用的人对其理解到什么程度。使用 React Hooks 就要尽量采用 immutable 变量，降低函数调用过频影响性能（部分 React 调度策略兜底）；使用 Vue 就尽量不要依赖跟踪丢失或者滥用依赖跟踪导致行为不可预测。\n最后 React 和 Vue 没有不可调和之处，他们是 JavaScript 这门语言一体两面的提现。\n未来哪个社区更加繁荣还是要看 TC39 把 JavaScript 带向何方，是更加 Functional Programming 呢？还是更加 Imperative Programming 呢？\n","date":"2020-05-10T00:00:00Z","image":"https://edward40.com/p/compare-vue-composition-api-with-react-hooks/vue_hu_f5f97ecc3ac07b19.jpg","permalink":"https://edward40.com/p/compare-vue-composition-api-with-react-hooks/","title":"对比 Vue Composition API 和 React Hooks"},{"content":" 自我推翻自我重建，我觉得是活着的人该做的事情。\n一个人要是对这个世界失去好奇心，失去求知欲，这个人已经是死的了。\n—— 摘自 Zeke\n2019 年，我从杭州阿里来到深圳腾讯工作的一年，这一年充满了感恩、迷茫、思考、转变。\n生活 在朋友的帮助下，我顺利的在深圳安顿下来，很感谢他。\n年头的时候去广州参加同学的婚礼，感觉时间过得好快。\n然后还和经常一起玩吃鸡、CSGO、彩六的网友见了一面，一起吃饭、玩耍。不过后面大家还是天南地北，很多回去学校了，真希望有缘能再聚一次。\n国庆的时候和家人一起去澳门玩，看了大三巴牌坊。\n在珠海长隆海洋王国看动物，大家都很喜欢海豹呢。\n其实我不是个喜欢和家人打电话的人，但内心家人对我来说非常的重要。同时我也感恩有一个智慧的妈妈，她爱阅读、爱思考，教会我如何待人接物、为人处事。\n我也努力沉下心来也读了一些书，如： 《旧制度与大革命》《1984》《学会提问：批判性思维指南》等等，渐渐也能收获阅读的乐趣。\n看过的频道 妈咪说 Mommy Talk\n在 B 站上看，主要是科普天文、数学、物理之类的，最近讲混沌非常有意思。\n3Blue1Brown\nYoutube 上看的，Grant Sanderson 从独特的视觉角度解说高等数学，也非常擅长开发，用可视化来让人快速理解数学之美。\nNiceChord\n讲乐理之类的，不过 Wiwi 官大为好像是个技术宅，也经常会放一些音乐编程的视频。\n看过的电视剧 《致命女人》：好看 《权力的游戏》：烂尾 《Years and Years》：噱头比较大 《切尔诺贝利》 《性爱自修室》 看过的番剧 《进击的巨人 第三季》：强烈推荐 《约定的梦幻岛》 《流汗吧！健身少女》 《Dr. STONE 石纪元》 《刀剑神域 Alicization 篇》 技能 健身 💪\n坚持了几个月，和同事一起去的，但后来健身房改造就没去（其实也是懒惰的理由）\n钢琴 🎹\n其实有点荒废这个天赋，希望 2020 能坚持下来\n煮饭 🍳\n买了一套厨具，不过没怎么用，果然还是不喜欢烧菜\n参与分享 6 月的时候，参加 GIAC 作为讲师分享 思考 其实过去的一年我生活在恐慌之中，我发现个人的成长几乎停滞不前。\n我开始反思自己为什么会这样？\n然后我发现了其实我是用工作麻痹自己，不肯直面 2018 的过去，失去了对自己对未来的信心。其实这并不能完全归咎于自己，不过沉迷不悟始终不是办法。\n这里要感谢 Zeke，在和他聊天过程中我找到了方向：我需要的是自我推翻自我重建，保持求知欲、好奇心。\n展望 2020 年我开始摈弃麻痹，不管多困难都要离开舒适圈。\n也给自己定下了一个目标：「让自己成为有影响力的人」\n","date":"2020-01-07T00:00:00Z","image":"https://edward40.com/p/review-2019/1_hu_151fc517f8bb8a29.jpeg","permalink":"https://edward40.com/p/review-2019/","title":"2019 年回顾总结"},{"content":"前言 相信大部分程序员都有自己个人网站，或者是托管在各大平台上的技术博客。\n大概在大一的时候我也萌生搭建个人博客的想法，最早还是比较流行自己买一个 VPS、域名，然后搭建 WordPress。不过由于没续费，东西也没妥善备份也不知道去哪里了。 接着网络兴起轻博客，我想着自己塔多不方便，就用了点点网写自己的博客，在上面沉淀不少文章，然而点点网在 2016 年也关闭了。\n自建和博客平台都不靠谱，我便转向了 GitHub Pages，正好那一阵流行用 hexo 生成静态博客站点，于是就搭建了一个放了些文章。其实放到现在来看主题还是挺好看的，不过由于我没有备份的良好习惯，有几篇文章的 md 文件被我弄丢了。\n因此，这次我把整个站点备份了一下（学乖了），并在上面盖新的个人网站。因为比较熟悉 React 的缘故，这次用的是 Gatsby 进行搭建。\n准备工作 安装 Gatsby CLI npm install -g gatsby-cli 创建项目 gatsby new 目录结构如下：\n. ├── LICENSE ├── README.md ├── content ├── gatsby-browser.js ├── gatsby-config.js ├── gatsby-node.js ├── node_modules ├── package-lock.json ├── package.json ├── src └── static 本地开发 gatsby develop 常用的插件 \u0026#34;gatsby-plugin-feed\u0026#34;: \u0026#34;^2.3.25\u0026#34;, \u0026#34;gatsby-plugin-google-analytics\u0026#34;: \u0026#34;^2.1.31\u0026#34;, \u0026#34;gatsby-plugin-manifest\u0026#34;: \u0026#34;^2.2.34\u0026#34;, \u0026#34;gatsby-plugin-offline\u0026#34;: \u0026#34;^3.0.30\u0026#34;, \u0026#34;gatsby-plugin-react-helmet\u0026#34;: \u0026#34;^3.1.18\u0026#34;, \u0026#34;gatsby-plugin-sharp\u0026#34;: \u0026#34;^2.3.10\u0026#34;, \u0026#34;gatsby-plugin-typography\u0026#34;: \u0026#34;^2.3.20\u0026#34;, \u0026#34;gatsby-remark-copy-linked-files\u0026#34;: \u0026#34;^2.1.33\u0026#34;, \u0026#34;gatsby-remark-images\u0026#34;: \u0026#34;^3.1.39\u0026#34;, \u0026#34;gatsby-remark-prismjs\u0026#34;: \u0026#34;^3.3.28\u0026#34;, \u0026#34;gatsby-remark-responsive-iframe\u0026#34;: \u0026#34;^2.2.30\u0026#34;, \u0026#34;gatsby-remark-smartypants\u0026#34;: \u0026#34;^2.1.19\u0026#34;, \u0026#34;gatsby-source-filesystem\u0026#34;: \u0026#34;^2.1.43\u0026#34;, \u0026#34;gatsby-transformer-remark\u0026#34;: \u0026#34;^2.6.45\u0026#34;, \u0026#34;gatsby-transformer-sharp\u0026#34;: \u0026#34;^2.3.9\u0026#34;, 配置及开发 配置 首先最重要的就是 gatsby-config.js 文件了，我们需要在里面启用上述安装的插件，配置可以到 sasuke40.githu.io 查看。\n还有得去 google analytics 配置一下记录站点的访问信息。 配置结束会给你个跟踪 ID，在配置文件 gatsby-plugin-google-analytics 下修改就行。\n开发 Dark Mode 其实上面配置完成基本上站点就能用了，不过 Gatsby 最好玩的是他的灵活。自带的没有夜间模式，下面我快速介绍一下怎么开发。\n注入全局函数 在 src 目录下新建 html.js，开发一个用于控制主题的全局函数 \u0026lt;script dangerouslySetInnerHTML={{ __html: ` (function() { window.__onThemeChange = function() {}; function setTheme(newTheme) { window.__theme = newTheme; preferredTheme = newTheme; document.body.className = newTheme; window.__onThemeChange(newTheme); } var preferredTheme; try { preferredTheme = localStorage.getItem(\u0026#39;theme\u0026#39;); } catch (err) { } window.__setPreferredTheme = function(newTheme) { setTheme(newTheme); try { localStorage.setItem(\u0026#39;theme\u0026#39;, newTheme); } catch (err) {} } var darkQuery = window.matchMedia(\u0026#39;(prefers-color-scheme: dark)\u0026#39;); darkQuery.addListener(function(e) { window.__setPreferredTheme(e.matches ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;) }); setTheme(preferredTheme || (darkQuery.matches ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;)); })(); ` }} /\u0026gt; 开发 Toggle 组件 准备好两张 Icon 图片，然后把 react-toggle 魔改一下就行。\n修改 layout { theme != null ? ( \u0026lt;Toggle icons={{ checked: ( \u0026lt;img src={moon} width=\u0026#34;16\u0026#34; height=\u0026#34;16\u0026#34; role=\u0026#34;presentation\u0026#34; style={{ pointerEvents: \u0026#39;none\u0026#39; }} /\u0026gt; ), unchecked: ( \u0026lt;img src={sun} width=\u0026#34;16\u0026#34; height=\u0026#34;16\u0026#34; role=\u0026#34;presentation\u0026#34; style={{ pointerEvents: \u0026#39;none\u0026#39; }} /\u0026gt; ) }} checked={theme === \u0026#39;dark\u0026#39;} onChange={e =\u0026gt; window.__setPreferredTheme(e.target.checked ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;) } /\u0026gt; ) : ( \u0026lt;div style={{ height: \u0026#39;24px\u0026#39; }} /\u0026gt; ) } 编写全局样式 编写 global.css 并在 typography.js 导入它，主要工作是给 body 配置 css 变量 body { --pink: rgb(255, 167, 196); background-color: var(--bg); } body.light { --bg: #ffffff; --bg-secondary: rgb(249, 250, 251); --header: var(--pink); --textNormal: #222; --textTitle: #222; --textLink: #d23669; --hr: hsla(0, 0%, 0%, 0.2); --inlineCode-bg: rgba(255, 229, 100, 0.2); --inlineCode-text: #1a1a1a; --form-shadow: 0 2px 15px 0 rgba(210, 214, 220, 0.5); } body.dark { -webkit-font-smoothing: antialiased; --bg: #282c35; --bg-secondary: rgb(54, 60, 72); --header: #ffffff; --textNormal: rgba(255, 255, 255, 0.88); --textTitle: #ffffff; --textLink: var(--pink); --hr: hsla(0, 0%, 100%, 0.2); --inlineCode-bg: rgba(115, 124, 153, 0.2); --inlineCode-text: #ffee93; --form-shadow: 0 2px 15px 0 rgba(26, 26, 27, 0.637); } 最终效果就是这样 部署 安装 gh-pages npm install gh-pages --save-dev 配置部署脚本 { \u0026#34;scripts\u0026#34;: { \u0026#34;deploy\u0026#34;: \u0026#34;gatsby build \u0026amp;\u0026amp; gh-pages -d public -b master\u0026#34; } } 推送源码到 dev 分支 Github Pages 有个特殊的规则，就是 \u0026lt;username\u0026gt;.github.io 会默认使用 master 分支中的生产代码。这也就是为什么 gh-pages -d public -b master 中是指定 master，而不是 gh-pages。\n因此，源码就需要放到非 master 分支上。我把博客的源码推到 dev 分支，并将其设置为默认。 推送构建后的生产代码 npm run deploy 推送后应该稍微等一下，就可以访问个人网站了。\n总结 Gastby 优势\n相当的灵活，给个人网站巨大的修改空间 支持 graphql，数据调用方便 生态强大，1500+ 数量的插件基本满足大部分需求 Gastby 劣势\n因其灵活，对个人博客的友好度就没那么高，md 文件及文件夹需要自己建立。不像 hexo 可以 hexo new [layout] \u0026lt;title\u0026gt; 这么方便 总体来说，我对 Gatsby 还挺满意的。要是大家挖掘到好玩的插件、好看的主题也欢迎留言。 最后，也欢迎大家互换友链 ➡️Edward Elric\n","date":"2020-01-07T00:00:00Z","image":"https://edward40.com/p/a-guide-to-building-a-personal-website-with-gatsby/gatsby_hu_2a2cc1ca622d4e61.jpg","permalink":"https://edward40.com/p/a-guide-to-building-a-personal-website-with-gatsby/","title":"使用 Gatsby 搭建个人网站指南"},{"content":"前言 看到这篇文章，可能很多人会有个疑问：“已经有 React + TypeScript 这么好的组合，为什么还想着使用 Rust 来写前端页面，不折腾吗？” 首先值得讨论的一点，接下来几年的前端方向有哪些？ 个人的愚见，在全栈领域必然是 serverless，我在业务开发中已经尝到甜头，高效、简便、心智负担很低了；而在 Web 领域，由于 2019 年 12 月 5 日— 万维网联盟（W3C）宣布 WebAssembly 核心规范成为正式标准，WASM 势必它的影响力会逐步提升。 WASM 的框架 / 库的选择已经比较丰富了，如：C# + Blazor、Go + Vugu、Rust + Yew 等等。 可能有人会问，为什么不能使用 TypeScript / JavaScript 来编译到 WASM，归根结底是因为 WASM 要求语言必须是静态强类型。当然可以魔改 TypeScript / JavaScript 做到这一点，例如 AssemblyScript / TurboScript 就是如此在 TypeScript / JavaScript 上做静态规范的。与其如此魔改，我个人觉得倒不如大大方方的使用静态强类型语言来编译到 WASM，反正魔改后也无法共享原有的生态。 那么为什么选择 Rust 而不是其他的诸如 Go、C#、C / C++ 呢？这个确实没有很有说服力的理由，只是出于个人的技术偏好，或者说是受到 RY 使用 Rust 实现 Deno 的鼓舞吧。\n准备 环境陈述 我使用的是 macOS，很多人自然会想到使用 homebrew 来完成 Rust 环境 setup。一开始我也是这么做的，不过会遇到下面问题：\nerror[E0463]: can\u0026#39;t find crate for `std` | = note: the `wasm32-unknown-unknown` target may not be installed 最后还是走官方推荐的方式解决的。\nRust Installation curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh Yew Installation cargo install wasm-pack cargo install cargo-web 上手 一些说明 Rust 本身就能实现编译到 WASM，使用 Yew 框架的原因就如其官网宣传：只是为了方便前端组件整合，以及对 JavaScript 互通性的考量。\n项目初始化 这里不采用官网提供的参考，因为示例过于简单，有些脱离真正应用场景。下面的步骤是我个人认为比较接近真实开发的状态，相关源码我也放到 GitHub 供大家玩耍 ➡️https://github.com/SASUKE40/yew-starter\ngit clone --depth=1 https://github.com/SASUKE40/yew-starter.git \u0026lt;project_name\u0026gt; 目录结构 . ├── Cargo.lock ├── Cargo.toml ├── LICENSE ├── README.md ├── index.html ├── index.js ├── package-lock.json ├── package.json └── src ├── app.rs └── lib.rs 这里面最重要的就是 Cargo.toml 了，其中最关键的依赖如下：\n[lib] crate-type = [\u0026#34;cdylib\u0026#34;] [dependencies] wasm-bindgen = \u0026#34;0.2\u0026#34; yew = \u0026#34;0.10.0\u0026#34; cdylib 是用于配置构建 C interoperability(C FFI)，wasm-bindgen 依赖是用于 WASM 模块和 JavaScript 之间的交互粘合。\n加载 WASM 以及 bind 的过程 mod app; use wasm_bindgen::prelude::*; #[wasm_bindgen] pub fn run_app() -\u0026gt; Result\u0026lt;(), JsValue\u0026gt; { yew::start_app::\u0026lt;app::App\u0026gt;(); Ok(()) } 在需要导出 Rust 函数到 JavaScript 中，只需要在函数方法上注释 #[wasm_bindgen] 即可，接着在 js 文件中导入使用\nimport { run_app } from \u0026#39;./lib\u0026#39; run_app() 构建套件 使用 Parcel 是最方便的，开箱即用。既可以直接 import rs，也可以 import wasm。 我这里用了 parcel-plugin-wasm.rs 插件完成 Cargo loader 的工作，和上述 import rs 的方式不同：\nimport { run_app } from \u0026#39;./Cargo.toml\u0026#39; run_app() Yew 组件编写体验 Yew 框架使用 html! macro 来生成 HTML\nimpl Component for App { type Message = Msg; type Properties = (); fn create(_: Self::Properties, _: ComponentLink\u0026lt;Self\u0026gt;) -\u0026gt; Self { App {} } fn update(\u0026amp;mut self, _msg: Self::Message) -\u0026gt; ShouldRender { true } fn view(\u0026amp;self) -\u0026gt; Html\u0026lt;Self\u0026gt; { html! { \u0026lt;p\u0026gt;{ \u0026#34;Hello world!\u0026#34; }\u0026lt;/p\u0026gt; } } } 模板中可以使用 html! { \u0026quot;Hello, World\u0026quot; } 这样的方式包裹文本或变量，这和 jsx 比较类似。 事件绑定、条件、循环也都是类似的，大同小异：\n// 点击事件 html!{ \u0026lt;button onclick=|_| Msg::Click\u0026gt;{ \u0026#34;Click Me!\u0026#34; }\u0026lt;/button\u0026gt; } // 条件渲染 html! { \u0026lt;div\u0026gt; { if show_link { html! { \u0026lt;a href=\u0026#34;https://example.com\u0026#34;\u0026gt;{\u0026#34;Link\u0026#34;}\u0026lt;/a\u0026gt; } } else { html! {} } } \u0026lt;/div\u0026gt; } // 迭代渲染 html! { \u0026lt;ul class=\u0026#34;item-list\u0026#34;\u0026gt; { for self.props.items.iter().map(renderItem) } \u0026lt;/ul\u0026gt; } 效果 Navigate to https://yew-starter.netlify.com/ 实际上 WASM 没有大家相信的那么“便携小巧”，WASM 吃掉的体积有 50kb。\n总结 其优势：\nWebAssembly 在桌面客户端移植到 Web 不可或缺 作为胶水包存在，如某面包姐姐最近就在尝试 Rust 2 WASM(CPP) 2 Node.js 其疑点： 高性能，感觉没有很突出到必须得这么做 可移植性，要做 Web 的 JVM？ WASM 的生态日趋丰富完善，未来 WASM 在前端必然会大放异彩。不过也无需夸大其地位，可以参考 WebAssembly 的出现是否会取代 JavaScript？这个知乎回答。摘抄官方对其定位的一个回答：WebAssembly 旨在作为 JavaScript 的补充而不是替代。 通宵写文，求 🌟🌟 求关注，不胜感激 ⬇️\nhttps://github.com/SASUKE40/yew-starter\n","date":"2020-01-05T00:00:00Z","image":"https://edward40.com/p/try-writing-fe-with-rust-yew/yew_hu_fffd306f7f9c9e6f.jpg","permalink":"https://edward40.com/p/try-writing-fe-with-rust-yew/","title":"尝试用 Rust + Yew 写高性能前端页面"},{"content":"第一步 安装 VSCode Insiders https://code.visualstudio.com/insiders/code.visualstudio.com\n目前只能在 VSCode Insiders 版本体验 Remote Development\n第二步 安装 Remote Development 插件 https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpackmarketplace.visualstudio.com\n第三步 配置 SSH Config SSH 配置文件\nHost ubuntu HostName \u0026lt;your-remote-host\u0026gt; User ubuntu 这里需要准备一个远端的机器，这样可以直接访问到服务器的文件。\n第四步 编写 Node 应用 基本就 4 个文件，已经放到 github 上： https://github.com/SASUKE40/docker_web_appgithub.com\n第五步 构建推送 docker 镜像 https://hub.docker.com/hub.docker.com\n在应用项目目录下执行镜像构建\ndocker build -t edward40/node-web-app .\n查看构建的镜像\ndocker images\n本地试跑镜像\ndocker run -p 3000:8080 -d edward40/node-web-app 访问 http://localhost:3000\n推送 Docker 镜像可以在终端执行\ndocker push edward40/docker_web_app:tagname 不过这里我用官方的自动化构建\n只要推送代码就会 build 出镜像\n第六步 服务器上跑镜像 在 SSH 终端中拉取 Node 应用镜像\nsudo docker pull edward40/docker_web_app 服务端启动 Container\nsudo docker run -p 80:8080 -d edward40/docker_web_app 第七步 本地开发 Docker Container 安装 Docker 插件\nhttps://marketplace.visualstudio.com/items?itemName=PeterJausovec.vscode-dockermarketplace.visualstudio.com\n项目目录创建配置文件\n创建 Container 配置文件\n不过因为使用 Alipine 导致无法打开\n需要切换别的 Linux 系统，并增加 .devcontainer.json 文件\n{ \u0026#34;name\u0026#34;: \u0026#34;Node.js Sample\u0026#34;, \u0026#34;dockerFile\u0026#34;: \u0026#34;Dockerfile\u0026#34;, \u0026#34;appPort\u0026#34;: 3000, \u0026#34;extensions\u0026#34;: [] } Dockerfile 的 alpine 换成 lts 版本\nFROM node:lts # Create app directory WORKDIR /usr/src/app # Install app dependencies # A wildcard is used to ensure both package.json AND package-lock.json are copied # where available (npm@5+) COPY package\\*.json ./ RUN npm install # If you are building your code for production # RUN npm ci --only=production # Bundle app source COPY . . EXPOSE 8080 CMD [ \u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34; ] 点击右下在容器中打开\n打开 Shell\n最终可以在容器中方便用终端\n使用容器终端\n使用总结 VSCode 的 Remote SSH 插件完美击中运维痛点，以后可以抛弃 Vim 直接在 VSCode 里面改东西，非常方便。 而 Remote Containers 插件就有点鸡肋，连到 Docker 容器中好像也没什么大的意义。个人更倾向代码提交触发 Docker Hub 的自动构建能力，并服务器上更新 Docker 镜像容器这样的工作流。如果有小伙伴发现这个插件更好的用法务必留言。 最后，VSCode Remote Development 快快 Release 吧！\n","date":"2019-05-17T00:00:00Z","image":"https://edward40.com/p/try-vscode-remote/vscode_hu_e2cc966b0fa35a6c.jpg","permalink":"https://edward40.com/p/try-vscode-remote/","title":"尝试一下 VSCode Remote 开发 Node 应用"},{"content":"前言 ry 近期把 deno 的第二版原型从 deno2 文件夹中转移到 src 上了，并初步完成之前定下针对 unprivileged 部分的改造目标：\nUse the gn build system for fast builds, sane configuration, and easy linking into Chrome. Use V8 snapshots to improve startup time. Remove Golang. Although it has been working nicely, I am concerned the double GC will become a problem sometime down the road. Distribute a C++ library called libdeno, containing the snapshotted typescript runtime. Test the message passing and other functionality at that layer before involving higher level languages. 翻译： 使用 GN 这个构建工具，这是 chromium 团队使用的构建工具 使用 V8 Snapshots 提升启动速度（已完成） **移除 Golang，**因为不想同时存在两个 GC（Go 和 TS） 弄了一个 C++ 库叫 libdeno，负责 TS 的运行时环境 试玩 克隆 Depot Tools git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 配置环境变量 这里我是把配置到 .zshrc 文件中\nexport PATH=$PATH:/path/to/depot_tools 克隆仓库 git clone git@github.com:ry/deno.git 进入到 src 文件夹 cd deno/src 获取包和 v8 gclient sync --no-history 然后你就会在 src 下看到一堆三方包和 v8 被下载下来\n安装 js 依赖 cd js yarn install gn gen out/Debug --args=\u0026#39;cc_wrapper=\u0026#34;ccache\u0026#34; is_debug=true \u0026#39; 使用 ninja 编译 mac 上得先安装 ccache 不然会报 subcommand failed 错误\nbrew install ccache 在 src 下进行编译\nninja -C out/Debug/ deno 试着执行 这样 deno 的执行文件就产生了\n接着运行看看\n打印出了 v8 的版本 V8 6.8.275.14\n","date":"2018-06-28T00:00:00Z","image":"https://edward40.com/p/try-deno2/deno_hu_732fc4d7fcc1d9d.png","permalink":"https://edward40.com/p/try-deno2/","title":"试玩 deno2"},{"content":"React 16.4 包含了一个 getDerivedStateFromProps 的 bugfix，这个 bug 导致一些 React 组件潜在的 bug 稳定复现。这个版本暴露了个案例，当你的应用正在使用反模式构建，则将会在此次修复后可能无法工作，我们对这个改动感到抱歉。在本文中，我们将阐述一些通常的使用 Derived State 的反模式以及相应的解决替代方案。\n在很长一段时间，在 props 改变时响应 state 的更新，无需额外的渲染，唯一的途径就是 componentWillReceiveProps 这个生命周期方法。在 16.3 版本下，我们介绍了一个替代的生命周期 getDerivedStateFromProps 更加安全的方式来解决相同的用例。同时，我们意识到人们有很多关于使用这两个方法的错误解读，我们发现了这些反模式导致一些微妙且令人困惑的 bug。 getDerivedStateFromProps 在 16.4 中做了修复，使得 derived state 更加可预测，因此滥用的后果更加容易被留意到。 Note 所有关于旧的 \u0026gt; componentWillReceiveProps 和新 \u0026gt; getDerivedStateFromProps 的反模式都会在本文中阐述。 这篇文章涵盖以下话题：\n什么时候使用 derived state\n使用 derived state 时通常的 bug\n反模式：无条件地将 prop 复制给 state\n反模式：当 props 改变时清除 state\n推荐的方案\n什么是 memoization ？\n什么时候使用 Derived State getDerivedStateFromProps 存在只为了一个目的。它让组件在 props 发生改变时更新它自身的内部 state。我们之前的文章提供一些例子，例如：基于 offset prop 的改变记录当前滚动位置或者 通过源 prop 加载外部数据。\n我们没有提供更多的例子，因为这有一个常规的准则，应该保守地使用 derived state。所有我们看到关于 derived state 的问题从根本上可以归结成两类：(1) 无条件的以 props 更新 state 或者 (2) 每当 props 和 state 不同时就更新 state。(我们将在下面谈到更多细节。)\n当你使用 derived state 来暂存一些仅基于当前 props 的计算结果时，你不需要 derived state。查看 什么是 memoization ?\n当你无条件更新 derived state 抑或是每当 props 与 state 不同时更新 state，你的组件可能会频繁重置它的 state。\n使用 Derived State 时的常见 bug “受控的” 和 “不受控的” 这两个术语经常涉及到 form 的 input，然而他们也能描述组件数据存在的位置。当数据作为 props 传递时，则数据可以被认为是受控的(因为父组件控制了这些数据)。仅存在于内部 state 的数据可以被认为是不受控的(因为父组件不能直接改变它)。\nderived state 的最常见错误就是混合了“受控”和“不受控”两种情况；当一个 derived state 值也使用 setState 来更新时，那它数据来源就不是唯一的。上文提到的“外部数据加载的例子”看上去好像就是这样，但其实有本质上差别。在数据加载例子中，\u0026lsquo;source\u0026rsquo; prop 和 \u0026rsquo;loading\u0026rsquo; state 都有明确的数据来源。当 \u0026lsquo;source\u0026rsquo; prop 改变时， \u0026rsquo;loading\u0026rsquo; state 总会被覆盖。相反地，state 当且仅当 prop 改变时才会被覆盖，否则只能被 state 所在的组件所管理。\n当这些约束被改变时问题就浮现了。这会产生两个经典形式。让我们看一看他们。\n反模式：无条件地将 prop 复制给 state 一个常见关于 getDerivedStateFromProps 和 componentWillReceiveProps 的错误理解就是他们只会在 props “变化”时调用。无论是组件重新渲染还是 props 和之前“不同”，这些生命周期方法都会被调用。基于此，这两个生命周期方法总是被用于不安全地无条件地覆盖 state。这样做将导致 state 的更新发生丢失。\n让我们思考一个例子来说明这个问题。这里有一个 EmailInput 组件“映射”了一个 email 属性在 state 中：\nclass EmailInput extends Component { state = { email: this.props.email } render() { return \u0026lt;input onChange={this.handleChange} value={this.state.email} /\u0026gt; } handleChange = event =\u0026gt; { this.setState({ email: event.target.value }) } componentWillReceiveProps(nextProps) { // This will erase any local state updates! // Do not do this. this.setState({ email: nextProps.email }) } } 首先，这个组件看上去没什么问题。State 被 props 传递进来的值所初始化，并在我们键入 \u0026lt;input\u0026gt; 的时候被更新。但是如果我们的父组件重新渲染的时候，我们输入到 input 的内容就会丢失(看这个例子)！即使我们在重置前进行比较 nextProps.email !== this.state.email也会这样。\n在这个简单的例子中，只有当 email 属性被改变时加入 shouldComponentUpdate 来解决重渲染。然而在实践中，组件总是接受多个 props；另一个 prop 改变时依然会导致重渲染和不当重置。在函数和对象属性在内部被创建，在一个实质性的变化发生时，实现 shouldComponentUpdate 可靠地只返回 true 值变得困难。这里有个 demo 展示发生的情况。因此， shouldComponentUpdate 作为性能优化的最好方式被使用，而不用在 derived state 中保证正确性。\n至此，为何无条件地将 props 复制给 state 是一个坏想法显而易见。在 review 可能的解决方案，让我们来看看一个有关的问题模式：在 email 属性改变时，如果我们只更新 state ？\n反模式：当 props 改变时清除 state 继续上述的例子，当 props.email 改变时，我们可以通过只更新来避免意外地清除 state：\nclass EmailInput extends Component { state = { email: this.props.email } componentWillReceiveProps(nextProps) { // Any time props.email changes, update state. if (nextProps.email !== this.props.email) { this.setState({ email: nextProps.email }) } } // ... } Note 不仅在以上例子中 \u0026gt; componentWillReceiveProps ,一个的反模式也被用于 \u0026gt; getDerivedStateFromProps 中。 我们做了很大的改进。现在我们的组件在 props 实质变化时才会清楚我们输入的内容。\n但依旧存在一个微妙的问题。想象一下一个密码管理应用使用上述输入组件。当在两个相同 email 的账户下切换时，输入组件重置会失败。这是因为两个账户传递给组件的 prop 值是相同的！这使得用户感到诧异，一个账户没有保存的变更会影响另一个共享同一 email 的账号上。(这里看 demo)\n这种设计是有本质缺陷的，但它是最容易犯的。(我就犯过！)幸运的是，以下有两个更好的替代方案。而关键就是对每一片数据，你需要选一个控制数据并以其作为真实源的简单组件，并避免副本数据存在于其他组件。让我们来看一下这些替代方案。\n优选方案 推荐：完全受控组件 一个避免上述涉及问题的途径就是完全地移除我们组件中的 state。如果 email 地址只存在于 prop，那我们没必要担心 state 的冲突。我们甚至可以把 EmailInput 缓存一个更加轻量的函数式的组件：\nfunction EmailInput(props) { return \u0026lt;input onChange={props.onChange} value={props.email} /\u0026gt; } 这个途径简化了我们组件的实现，但是我们如果想存储草稿的时候，父组件还是需要手工完成这件事。(点这看这种模式的例子)\n推荐：带有 key 的完全不受控组件 另一个替代方案就是我们的组件完全的控制自己的 email state “草稿”。在此例子中，我们的组件依然可以接收一个来自于初始值，但它将会忽略后面 prop 的改动：\nclass EmailInput extends Component { state = { email: this.props.defaultEmail } handleChange = event =\u0026gt; { this.setState({ email: event.target.value }) } render() { return \u0026lt;input onChange={this.handleChange} value={this.state.email} /\u0026gt; } } 为了能在不同的情境下重置值(如密码管理方案)，我们使用特殊的 React 属性 key 。当 key 改变时，React 将创建一个新的组件实例而不是更新现有的这个。Keys 经常被用于动态 list，但在这里依然管用。在我们的案例中，我们能根据 user ID 在新用户被选中时重新创建 email 输入组件：\n\u0026lt;EmailInput defaultEmail={this.props.user.email} key={this.props.user.id} /\u0026gt; 每当 ID 改变时， EmailInput 将会被重新创建，它的 state 将会用最新的 defaultEmail 值重置。(点这里看这种模式的例子)使用这种途径，你不需要为每一个输入组件加 key 。也许在 from 中加一个 key 会来得更好。每当 key 改变时，所有在 from 里的组件都会用一个新的 initialized state 来重新创建。\n更多的案例中，这是一个处理需要被重置的 state 的最佳方式。 Note 虽然这貌似会很慢，在性能差异无关紧要的时候。当组件有很重的更新逻辑时候，使用一个 key ，忽略子树 diffing 甚至会更快。\n替代方案 1：使用 ID prop 重置不受控组件 如果 key 由于某些原因不能被使用(也许组件有昂贵的初始化代价)，一个可行但笨重的方案就是在 getDerivedStateFromProps 中监听 “userID” 的改变：\nclass EmailInput extends Component { state = { email: this.props.defaultEmail, prevPropsUserID: this.props.userID } static getDerivedStateFromProps(props, state) { // Any time the current user changes, // Reset any parts of state that are tied to that user. // In this simple example, that\u0026#39;s just the email. if (props.userID !== state.prevPropsUserID) { return { prevPropsUserID: props.userID, email: props.defaultEmail } } return null } // ... } 这也提供了灵活性——重置部分被我们选中的组件内部 state。(点这里看此模式的 demo) Note 及时以上例子展示了 \u0026gt; getDerivedStateFromProps ，同样的技术手段也可以被用在 \u0026gt; componentWillReceiveProps 。\n替代方式 2：在一个实例方法中重置不受控组件 更罕见地，你可能需要重置 state 即使没有适当的 ID 可用为 key 。一个解决方案就是每次你想重置时用一个随机数或者自增数字重置 key。另一个可行的方案是暴露一个实例方法命令式的重置内部 state：\nclass EmailInput extends Component { state = { email: this.props.defaultEmail } resetEmailForNewUser(newEmail) { this.setState({ email: newEmail }) } // ... } 父组件能用 ref 来调用这个方法。(点击这看这个模式例子)\nRefs 在这个确定的例子中是有用的，但通常上我们建议你保守使用。甚至在这个 demo 中，这个必要的方法是不理想的，因为本来一次的渲染会变成两次。\n扼要重述 重述一下，当设计一个组件的时候，决定数据是否受控或不受控是至关重要的。\n让组件变得受控，而不是试图在** state 中复制一个 prop **，在一些父组件的 state 中联合两个分散的值。举个例子，与其子组件接收一个“已提交的” props.value 并跟踪一个“草稿” state.value ，不如在父组件中管理 state.draftValue 和 state.committedValue ，并控制直接控制子组件的值。这让数据流更加明确和可预测。\n对不受控组件，如果你在一个特殊的 prop (通常是 ID)改变时试图重置 state，你有一些选择：\n推荐：重置所有内部 state，使用 key 属性\n替代方案 1：仅重置确定的 state 字段，监听特定属性的变化(例如： props.userID)。\n替代方案 2：你也可以考虑使用 refs 调用一个命令式实例方法。\n什么是 memoization ? 我们也看到，仅当输入变化的时候，derived state 被用于确保关键值被用于 render 中会重新计算。这个技巧被称之为 memoization。\n使用 derived state 来完成 memoization 并不一定是坏事，但这经常不是最佳方案。管理 derived state 具有内在复杂度，这个复杂度随着属性的增加而提升。例如，如果我们想要加入第二个 derived feild 到我们的组件 state，那么我们的实现将需要分别跟踪两者的变化。\n让我们来看一个例子——组件携带一个属性(一个 item list)，并渲染匹配用户输入的搜索查询的 item。我们使用 derived state 存储过滤的 list：\nclass Example extends Component { state = { filterText: \u0026#39;\u0026#39; } // ******************************************************* // NOTE: this example is NOT the recommended approach. // See the examples below for our recommendations instead. // ******************************************************* static getDerivedStateFromProps(props, state) { // Re-run the filter whenever the list array or filter text change. // Note we need to store prevPropsList and prevFilterText to detect changes. if ( props.list !== state.prevPropsList || state.prevFilterText !== state.filterText ) { return { prevPropsList: props.list, prevFilterText: state.filterText, filteredList: props.list.filter(item =\u0026gt; item.text.includes(state.filterText) ) } } return null } handleChange = event =\u0026gt; { this.setState({ filterText: event.target.value }) } render() { return ( \u0026lt;Fragment\u0026gt; \u0026lt;input onChange={this.handleChange} value={this.state.filterText} /\u0026gt; \u0026lt;ul\u0026gt; {this.state.filteredList.map(item =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.text}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt; ) } } 这个实现避免了不必要 filteredList 的重新计算。但这比原来的更复杂，因为他必须分开跟踪和检测 props 和 state 的变化，才能正确更新过滤后的列表。在这个例子中，我们能使用 PureComponent 简化工作，移动更新操作到 render 方法中：\n// PureComponents only rerender if at least one state or prop value changes. // Change is determined by doing a shallow comparison of state and prop keys. class Example extends PureComponent { // State only needs to hold the current filter text value: state = { filterText: \u0026#39;\u0026#39; } handleChange = event =\u0026gt; { this.setState({ filterText: event.target.value }) } render() { // The render method on this PureComponent is called only if // props.list or state.filterText has changed. const filteredList = this.props.list.filter(item =\u0026gt; item.text.includes(this.state.filterText) ) return ( \u0026lt;Fragment\u0026gt; \u0026lt;input onChange={this.handleChange} value={this.state.filterText} /\u0026gt; \u0026lt;ul\u0026gt; {filteredList.map(item =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.text}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt; ) } } 这种途径比用 derived state 更加清晰且简单。偶尔地，这不够好——在大列表中过滤会变得慢，如果其他 prop 变化时 PureComponent 不会阻止重渲染。为了解决这些问题，我们可以加入一个 memoization helper 来避免对 list 的不必要过滤：\nimport memoize from \u0026#39;memoize-one\u0026#39; class Example extends Component { // State only needs to hold the current filter text value: state = { filterText: \u0026#39;\u0026#39; } // Re-run the filter whenever the list array or filter text changes: filter = memoize((list, filterText) =\u0026gt; list.filter(item =\u0026gt; item.text.includes(filterText)) ) handleChange = event =\u0026gt; { this.setState({ filterText: event.target.value }) } render() { // Calculate the latest filtered list. If these arguments haven\u0026#39;t changed // since the last render, `memoize-one` will reuse the last return value. const filteredList = this.filter(this.props.list, this.state.filterText) return ( \u0026lt;Fragment\u0026gt; \u0026lt;input onChange={this.handleChange} value={this.state.filterText} /\u0026gt; \u0026lt;ul\u0026gt; {filteredList.map(item =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.text}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/Fragment\u0026gt; ) } } 这更加简单，而且性能和 derived state 版本的一样好！\n当使用 memoization 时，记住一些约束条件：\n在大多数案例中，你会想把 memoized 函数附加到组件实例上。这防止一个组件的多个实例重置彼此的 memoized key。\n通常地，你会想使用一个具有缓存大小限制的 memoization helper 来避免内存泄露问题。（在以上的例子中，我们用了 memoize-one 因为它仅缓存最近的参数和结果。）\n如果 props.list 在每次父组件渲染时被重新创建，本节中展示的实现手段是无法工作的。但在多数案例中，这种设置是适当的。\n结语 在实际的应用中，组件经常包含受控和不受控行为的混合。这是没问题的！如果每一个值都有清晰的真实源，你可以避免上面提及的反模式。\n同样值得重申的是， getDerivedStateFromProps (一般的 derived state) 是一个高级特性，由于其复杂度，应该保守的使用它。如果你使用的案例超出这些模式，请在 Github 或 Twitter 上与我们分享！\n原文链接：You Probably Don\u0026rsquo;t Need Derived State - React Blog\n","date":"2018-06-15T00:00:00Z","image":"https://edward40.com/p/you-may-dont-need-drevied-state/react-derived-state_hu_2806432fdd4074de.jpg","permalink":"https://edward40.com/p/you-may-dont-need-drevied-state/","title":"你可能不需要 Derived State"},{"content":"前言 可能大家會問：“官網示例那麼簡單，有必要講解嗎？”，我的看法是：“非常需要！”。一般而言，官方文檔是學習新知識最好的去處，你可以瞭解它的理念、思想、模式和 API 等等，可謂是無所不包。相對來說，官網的 Sample 就是能快速的瞭解和切入的直觀體現。因此，今天來看看官網的示例要告訴我們什麼，相信它對感興趣 React 但是不是很瞭解的人可以有個感性的瞭解。\n什麼是 React（個人見解/官方簡介轉述） 它只做 UI 層面的事，你可以理解為是 Web Component 的特殊實現 Virtual DOM，就一個字：“快”，同時支持服務端渲染 數據流，單向的數據綁定足夠應付大部分的業務場景，同時使得數據和事件的流動變得清晰 怎麼開始用上 React 這裡我們先不用 Webpack、gulp 這些這麼“高級”的工具，方便小白入門。 我們直接引入對應的腳本更加方便，大概是這樣子的：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;React Sample 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/babel-core/5.8.34/browser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-with-addons.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; var mountNode = document.getElementById(\u0026#39;container\u0026#39;) var HelloMessage = React.createClass({ render: function() { return \u0026lt;div\u0026gt;Hello {this.props.name}\u0026lt;/div\u0026gt; } }) ReactDOM.render(\u0026lt;HelloMessage name=\u0026#34;SASUKE40\u0026#34; /\u0026gt;, mountNode) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 這是官網的第一個示例，當然官網略去了很多東西沒說。 先說一下上面代碼我加了的東西：\nbrowser.js 是 babel 的瀏覽器版本，babel 是一個很酷的東西，自己 Google 下就知道有多酷。提示一下，千萬別急著用 babel6，你會用哭的~ react 就不必多說了，我們的主角 react-dom 是最近從 react 拆出來的，以前是包在 react 中的 細心的朋友可能看到 type=\u0026quot;text/babel\u0026quot; 這個奇怪的類型屬性，其實它是為了讓 babel 能去轉換 jsx 成瀏覽器讀得懂兼容較好的 JavaScript\n示例初步講解 為什麼說初步呢？因為深挖底層具體的動作，可能很多人都會暈，所以只講表層我們看的到的東西。\n第一個官方示例主要分成兩個步驟：\n創建 React 類，使用 React.createClass 創建，傳入一個 object， 這個 object 有個成員屬性 render 返回 jsx 用 ReactDOM 如渲染並掛載到某個具體的 DOM 節點上 額外的 Tip：在這裡的 \u0026lt;div\u0026gt;Hello {this.props.name}\u0026lt;/div\u0026gt; 這一部分並不是 HTML，而是貨真價實的 JavaScript，並且創建出來對象是 React 實例，並不是 HTML 的 DOM 節點。\n使用 React 在這個示例的好處 可以自定義標籤屬性，在渲染的時候可以插入到內容中\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;React Sample 2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/babel-core/5.8.34/browser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-with-addons.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; var mountNode = document.getElementById(\u0026#39;container\u0026#39;) var Timer = React.createClass({ getInitialState: function() { return { secondsElapsed: 0 } }, tick: function() { this.setState({ secondsElapsed: this.state.secondsElapsed + 1 }) }, componentDidMount: function() { this.interval = setInterval(this.tick, 1000) }, componentWillUnmount: function() { clearInterval(this.interval) }, render: function() { return \u0026lt;div\u0026gt;過去了：{this.state.secondsElapsed}秒\u0026lt;/div\u0026gt; } }) ReactDOM.render(\u0026lt;Timer /\u0026gt;, mountNode) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 這個示例多了好多：\ngetInitialState 是一個關鍵的成員屬性，它可以初始化 state，在 render 中可以調用 this.state.xxx 就能拿到 tick 是一個自定義的成員屬性，其中 this.setState 是 React 類的關鍵方法，可以修改 state 的值 componentDidMount 顧名思義，在掛載後執行一些東西，這裡是弄了個定時器 componentWillUnmount 也顧名思義，將要卸載的時候做點事情，良好的編碼習慣，這裡清除定時 示例 3 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;React Sample 3\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/babel-core/5.8.34/browser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-with-addons.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; var mountNode = document.getElementById(\u0026#39;container\u0026#39;) var TodoList = React.createClass({ render: function() { var createItem = function(item) { return \u0026lt;li key={item.id}\u0026gt;{item.text}\u0026lt;/li\u0026gt; } return \u0026lt;ul\u0026gt;{this.props.items.map(createItem)}\u0026lt;/ul\u0026gt; } }) var TodoApp = React.createClass({ getInitialState: function() { return { items: [], text: \u0026#39;\u0026#39; } }, onChange: function(e) { this.setState({ text: e.target.value }) }, handleSubmit: function(e) { e.preventDefault() var nextItems = this.state.items.concat([ { text: this.state.text, id: Date.now() } ]) var nextText = \u0026#39;\u0026#39; this.setState({ items: nextItems, text: nextText }) }, render: function() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;TODO\u0026lt;/h3\u0026gt; \u0026lt;TodoList items={this.state.items} /\u0026gt; \u0026lt;form onSubmit={this.handleSubmit}\u0026gt; \u0026lt;input onChange={this.onChange} value={this.state.text} /\u0026gt; \u0026lt;button\u0026gt;{\u0026#39;Add #\u0026#39; + (this.state.items.length + 1)}\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; ) } }) ReactDOM.render(\u0026lt;TodoApp /\u0026gt;, mountNode) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 關鍵點：\n標籤可以嵌套 可以些一些事件，以自定義事件函數體現，不管這裡的是 JavaScript 的事件，並不是 DOM 節點上定義的 列表組件定義的一種推薦寫法：this.props.items.map 傳入單個組件 示例 4 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;React Sample 4\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/babel-core/5.8.34/browser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-with-addons.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/react/0.14.7/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://cdn.bootcss.com/marked/0.3.5/marked.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; var mountNode = document.getElementById(\u0026#39;container\u0026#39;) var MarkdownEditor = React.createClass({ getInitialState: function() { return { value: \u0026#39;Type some *markdown* here!\u0026#39; } }, handleChange: function() { this.setState({ value: this.refs.textarea.value }) }, rawMarkup: function() { return { __html: marked(this.state.value, { sanitize: true }) } }, render: function() { return ( \u0026lt;div className=\u0026#34;MarkdownEditor\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Input\u0026lt;/h3\u0026gt; \u0026lt;textarea onChange={this.handleChange} ref=\u0026#34;textarea\u0026#34; defaultValue={this.state.value} /\u0026gt; \u0026lt;h3\u0026gt;Output\u0026lt;/h3\u0026gt; \u0026lt;div className=\u0026#34;content\u0026#34; dangerouslySetInnerHTML={this.rawMarkup()} /\u0026gt; \u0026lt;/div\u0026gt; ) } }) ReactDOM.render(\u0026lt;MarkdownEditor /\u0026gt;, mountNode) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 關鍵點：\n可以使用自定義函數用作過濾器，如這裡引入的 marked.js 裏的 marked() React 中的設置 HTML 的 APIdangerouslySetInnerHTML，返回含有 __html 屬性的 object 即可 使用 refs 拿到 DOM？思考一下是不是吧~ 額外的 Tip：React 還沒有 1.0.0，很多都經常變化，refs 在以前不是這麼拿到，哭死我們這些前端小白了~\n結語 前端之路還很長，React 大法好啊~\n","date":"2016-03-01T00:00:00Z","image":"https://edward40.com/p/react-official-sample-explanation/react_hu_4d1dc8130d6efcd0.png","permalink":"https://edward40.com/p/react-official-sample-explanation/","title":"React 官網示例講解"},{"content":"2015 年過去的好快，在荔枝 FM 帶了好像沒有多久的時間，其實也不算短，將近一年了。\n我在知乎上改了簽名：“2015 过去了，2016 又会怎么样……”，其實對 2016 年還是蠻忐忑的，因為有計畫想要換一份新的工作，但是覺得自己水平還不夠強。\n說說在荔枝 FM 的一年吧！想起來還是 2015 年 3 月的時候，那是我在知乎上搜了一下“互聯網 廣州”，然後看到了一個問題“广州有哪些比较酷的互联网公司？”，注意到荔枝 FM 這家公司。\n後來我就看了下荔枝 FM 的官網，找到了前端的崗位，但是那個崗位要求好高，要 3 年工作經驗。那時的荔枝 FM 貌似並不招應屆生，不過我抱著試一試的心態投了簡歷。沒想的是，要不到一天電話聯繫我，說那邊的老大對我比較感興趣，問我要不要去面試。然後我就很冷靜的說好，其實內心很激動 ╰(￣ ▽ ￣)╮\n一切還是蠻順利的，我進了荔枝 FM，做了一名前端碼農。那時公司還不是很多人，我進去的時候也就五六十人，前端也就導師和我在做。雖然天天被催著做移動端的頁面，還有一些專題頁，還要寫後端，沒辦法人少但是那時真的好快樂，幸福感爆表。現在進荔枝 FM 的小夥伴應該很難體會在增園那一段的時間。在創業公司有不少感觸，好的地方是你可以接觸各式各樣的工作，除了做前端，我偶爾也參與設計，例如：開屏圖、banner，參與和客戶端的同事共同做內置瀏覽器的接口，前後端一手包，瞭解很多營銷的技巧，產品思想，等等……我在這一年成長的很快。不好的地方也很多，你想把很多東西做到極致的比較難，即使你想做。一方面是很多時候你是在對付業務，另一方面是我進去的時候前端可以說是沒有基建的，很多東西都要自己去 Initial building，所以沒有做到極致的條件。例如說是使用 webpack、gulp 和後端融合，CDN 加速，前後端分離，DNS 預取，React 和 Vue 預研應用。其中有一回蠻有挫敗感的，我花了接近兩個星期做了前端分享準備，做 PPT，寫逐字稿，寫 Demo，分享一個關於“Web Component”的主題。但是由於大部分同事還是做後端的（在很多後端眼裏，前端都是玩具的說＞﹏＜），所以反映平平。 言歸正傳，說說 2016 吧！最近面了很多互聯網公司，大大小小各式各樣的都有，其實蠻累的，現在也拿到了心儀的 offer 了，就和大家分享一下在廣州前端面試的一些感悟\n廣州算是沒什麼大的互聯網公司，騰訊在深圳，阿里在杭州，百度在北京。廣州呢，也就是 WXG、MIG、阿里 UC、唯品會、YY、網易一類，除了唯品會和 YY，在這裡的大公司都是分部。面試的感覺是廣州的大公司其實都比較中規中矩，而小公司都是比較跳。為什麼這麼說呢？因為大公司的分部一般來說會思維比較體系化了，更多的是穩重求進。舉個例子，MIG 的前端部分並沒有什麼硬性的技術選型，你想用 React 就用，想用 Vue 就用，jQuery 都 ok，用什麼構建工具都可以，只要能完成業務。小公司（不計其數）的想法比較跳，例如用比較潮的 nodejs、webpack、python、go 等等，但是經常會在技術選型上漂浮不定，用 Express 發現不夠完美換成 koa 的不少，糾結用 React、Vue 還是 Angular，用了 Grunt 又換 Gulp。其實我的看法是，不要糾結框架、工具鏈~\n當然你會問我最後去哪裡了？我想是天貓前端。天貓的前端算是業務核心，在那裡可以有一個很好的團隊，很牛很棒的上司。天貓的技術選型（React+babel+gulp）也很吸引熱愛前端的人。只是有一點，我很捨不得廣州，這裡有滿滿的回憶，給我幸福感和歸屬感。我怕去了杭州會不習慣，然而為了熱愛的前端還是值得的~ 最後，「Stay hungry. Stay foolish.」\n","date":"2016-02-27T00:00:00Z","image":"https://edward40.com/p/interview-in-guangzhou-2016/guangzhou_hu_df14fe38b44595ac.jpg","permalink":"https://edward40.com/p/interview-in-guangzhou-2016/","title":"2016 年廣州前端面試之旅"},{"content":" 安装 apt 源管理工具、添加 nginx 和 php 的安装源 apt-get install python-software-properties add-apt-repository ppa:nginx/stable add-apt-repository ppa:ondrej/php5 更新系统软件 apt-get update 安装 mysql apt-get install mysql-server mysql-client 安装 php 及对 mysql 的支持 apt-get install php5-fpm php5-mysql 根据实际需要，选择性的安装 php 的各类功能模块 apt-get install php-pear php5-dev php5-curl apt-get install php5-gd php5-intl php5-imagick apt-get install php5-imap php5-mcrypt php5-memcache apt-get install php5-ming php5-ps php5-pspell apt-get install php5-recode php5-snmp php5-sqlite apt-get install php5-tidy php5-xmlrpc php5-xsl 安装 nginx apt-get install nginx 修改 nginx 默认站点配置文件 vim /etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; index index.php index.html index.htm; server_name server_domain_name_or_IP; location / { try_files $uri $uri/ =404; } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } location ~ \\.php$ { try_files $uri =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } ","date":"2016-02-06T00:00:00Z","image":"https://edward40.com/p/php-installation/php_hu_4fbd43a51422ee12.png","permalink":"https://edward40.com/p/php-installation/","title":"Ubuntu 安裝 php"},{"content":"安裝 Activator 先下載Activator 解壓到D:\\Program Files\\activator-1.3.2 將D:\\Program Files\\activator-1.3.2加到環境變量 Path 中 在你的項目目錄中執行以下命令，驗證是否安裝成功\nactivator -help 創建 Play 項目 activator new demo play-java cd demo activator 安裝 Eclipse 插件 Scala IDE 在 Eclipse 中 Install New Software 增加宰割 Update Site，記得安裝 Play Support\n創建 Eclipse 項目 eclipse with-source=true 跑起來看看 run 在瀏覽器中打開http://localhost:9000，項目就跑起來了 ╰(￣ ▽ ￣)╮\n","date":"2015-05-23T00:00:00Z","image":"https://edward40.com/p/play-framework/play_hu_c61a98a4f3ed6a30.jpg","permalink":"https://edward40.com/p/play-framework/","title":"Play Framework項目初始化"},{"content":" 添加 ppa sudo add-apt-repository ppa:webupd8team/java 更新系統 sudo apt-get update 安裝 java8 sudo apt-get install oracle-java8-installer 檢測是否成功 java -version 結果如下\njava version \u0026#34;1.8.0_45\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_45-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode) 設置環境變量 sudo apt-get install oracle-java8-set-default 版本切換 sudo update-java-alternatives -s java-8-oracle ","date":"2015-05-23T00:00:00Z","image":"https://edward40.com/p/java8-installation/java8_hu_131caf8842af5c26.jpg","permalink":"https://edward40.com/p/java8-installation/","title":"Ubuntu安裝java8"},{"content":"寫這篇文章的初衷 想想在荔枝 FM 工作接近 2 個月了，一直沒能好好總結是一個很大的問題，因此今天就來寫一些東西來回顧一下過去的工作。\n工作列表 荔枝達人 HTML5 遊戲 運營後臺·標記播客庫 微信錄音 錄音指南 HTML5 程壁線下文藝店 HTML5 主播資料收集頁 HTML5 Young 榜 HTML5 推廣後臺 工作中用到的東西 荔枝達人 HTML5 遊戲使用 egret（白鷺）引擎，這個引擎是使用TypeScript來寫。TypeScript 感覺挺好的，顯式類型並且接近 ES6 規範，但是有一點比較坑的是，對於第三方庫的引入不是很理想，表面而言就是引用的第三方庫後綴為d.ts。\n有時間就謝謝TypeScript的一些東西和大家分享。\n運營後臺 運營後臺使用的是公司自己編寫的 Java 後端框架，一開始我一直在熟悉這個框架，覺得很不適用，但是當我仔仔細細的看過後又挺欽佩前人的智慧。在熟悉完項目之後就開始編寫自己的功能模塊了。這個項目是使用自己定義的 MVC 框架，定義了一些 Controller 規範，已經對應 View 的規則，使用的持久化框架是MyBatis。Model 對 MyBatis 進行封裝，可在選擇在自動事務和自行事務處理，默認為自動事務。總體而言，在寫完一個功能模塊並使之上線算是一次完整的框架“遊覽”。\n順便提一個，部署這一塊也是挺有趣的。公司在安全方面挺注重的，因此每個人要將項目部署上去都必須經過跳板機。感謝公司“萬能”的運維大大，在跳板機上有對應掛載的目錄，因此部署也不是太麻煩。我使用的是 XShell，對應的上傳下載命令也就是rz和sz。\npo 一下最近學習的運維知識（果然 Linux 課都白上了，只學到 ls 和 sudo） 以下出於安全考慮，全部 command 都隱去敏感字符\nssh -p port host@192.168.1.1 mysql -uname -p -h 192.168.1.1 -P port database_name 順便 po 一下最近自學的 mysql 權限處理\nservice mysql stop /usr/bin/mysqld_safe --skip-grant-tables \u0026amp; use mysql; INSERT INTO user VALUES (\u0026#39;localhost\u0026#39;,\u0026#39;root\u0026#39;,password(\u0026#39;\u0026#39;),\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;); INSERT INTO user VALUES (\u0026#39;127.0.0.1\u0026#39;,\u0026#39;root\u0026#39;,password(\u0026#39;\u0026#39;),\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;); INSERT INTO user VALUES (\u0026#39;::1\u0026#39;,\u0026#39;root\u0026#39;,password(\u0026#39;\u0026#39;),\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;); INSERT INTO user VALUES (\u0026#39;%\u0026#39;,\u0026#39;root\u0026#39;,password(\u0026#39;\u0026#39;),\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;); flush privileges; ps aux | grep \u0026#39;mysql\u0026#39; kill -9 mysqld-pid service mysql start vim /etc/mysql/my.cnf bind-address = 127.0.0.1 上面這些有的是為了遠程訪問Mysql，看不懂就算了，關於運維以後再補。\n微信錄音 做微信录音讓我知道了 Redis 可以用來做服務，這種方式真的很“潮”，這個項目是使用Play Framework作為後端的。 下面講講這個Play Framework\nPlay Framework和Ruby on Rails非常相似，算是 Java 的 Rails，編寫東西相當敏捷，配置很靈活，缺點也有，模版引擎略坑。這個框架有很多配套的組件，Eclipse 的 Scala IDE，Play Support，sbt，activator，等等。一些實踐，怎麼編寫 Annotation 實現簡單權限，怎麼用 less，怎麼打包部署，編寫 reload 腳本等等。發現好多東西要補，5555……\n錄音指南 這是一個翻頁 HTML5，因為是一個靜態的項目，而且比較獨立，所以這個項目用了很多前端的東西，列表如下：\nyeoman glup webstorm bower browser-sync（這是個非常好的東西） n 多的 gulp 插件 項目部署在nginx下。\n關於移動端 head 的較好處理\n\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;target-densitydpi=device-dpi, width=640px, user-scalable=no\u0026#34; /\u0026gt; \u0026lt;!-- 删除苹果默认的工具栏和菜单栏 --\u0026gt; \u0026lt;meta name=\u0026#34;apple-mobile-web-app-capable\u0026#34; content=\u0026#34;yes\u0026#34; /\u0026gt; \u0026lt;!-- 设置苹果工具栏颜色 --\u0026gt; \u0026lt;meta name=\u0026#34;apple-mobile-web-app-status-bar-style\u0026#34; content=\u0026#34;black\u0026#34; /\u0026gt; \u0026lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --\u0026gt; \u0026lt;meta name=\u0026#34;format-detection\u0026#34; content=\u0026#34;telephone=no, email=no\u0026#34; /\u0026gt; \u0026lt;!-- 启用360浏览器的极速模式(webkit) --\u0026gt; \u0026lt;meta name=\u0026#34;renderer\u0026#34; content=\u0026#34;webkit\u0026#34; /\u0026gt; \u0026lt;!-- 避免IE使用兼容模式 --\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --\u0026gt; \u0026lt;meta name=\u0026#34;HandheldFriendly\u0026#34; content=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 微软的老式浏览器 --\u0026gt; \u0026lt;meta name=\u0026#34;MobileOptimized\u0026#34; content=\u0026#34;320\u0026#34; /\u0026gt; \u0026lt;!-- uc强制竖屏 --\u0026gt; \u0026lt;meta name=\u0026#34;screen-orientation\u0026#34; content=\u0026#34;portrait\u0026#34; /\u0026gt; \u0026lt;!-- QQ强制竖屏 --\u0026gt; \u0026lt;meta name=\u0026#34;x5-orientation\u0026#34; content=\u0026#34;portrait\u0026#34; /\u0026gt; \u0026lt;!-- windows phone 点击无高光 --\u0026gt; \u0026lt;meta name=\u0026#34;msapplication-tap-highlight\u0026#34; content=\u0026#34;no\u0026#34; /\u0026gt; \u0026lt;!-- UC强制全屏 --\u0026gt; \u0026lt;meta name=\u0026#34;full-screen\u0026#34; content=\u0026#34;yes\u0026#34; /\u0026gt; \u0026lt;!-- QQ强制全屏 --\u0026gt; \u0026lt;meta name=\u0026#34;x5-fullscreen\u0026#34; content=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 360强制全屏 --\u0026gt; \u0026lt;meta name=\u0026#34;360-fullscreen\u0026#34; content=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- UC应用模式 --\u0026gt; \u0026lt;meta name=\u0026#34;browsermode\u0026#34; content=\u0026#34;application\u0026#34; /\u0026gt; \u0026lt;!-- QQ应用模式 --\u0026gt; \u0026lt;meta name=\u0026#34;x5-page-mode\u0026#34; content=\u0026#34;app\u0026#34; /\u0026gt; \u0026lt;!-- 适应移动端end --\u0026gt; \u0026lt;!-- Place favicon.ico in the root directory --\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/assets/favicon.ico\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; 鎖定在 640px 就不用擔心什麼了，話說那些這麼寫的是要做什麼\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,target-densitydpi=high-dpi,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\u0026#34; /\u0026gt; 程壁線下文藝店 \u0026amp; 主播資料收集頁 這兩個差不多，都是 HTML5 表單，後端也是Play Framework（真的挺好用的框架），用了一下百度統計和騰訊分析，感覺不錯。\nYoung 榜 HTML5 這個任務拖了我一個多星期，本來預計兩三天結果，結果設計師和市場一直在糾結設計需求，不過要不是這樣也不會有一個好用的推廣後臺 ╮(╯▽╰)╭， 這個東西用了Swiper，很贊的觸摸滑動插件，對移動端支持很棒。\n這個 HTML5 是可以配置修改的，只要在後臺設置好就能生成新的一期了，總體來說還 ok。\n推廣後臺 這個也能講一大堆，暫時不講了，休息休息~~\n","date":"2015-05-23T00:00:00Z","image":"https://edward40.com/p/work-experience/work_hu_e8393d5a7f861e74.jpg","permalink":"https://edward40.com/p/work-experience/","title":"工作心得"}]