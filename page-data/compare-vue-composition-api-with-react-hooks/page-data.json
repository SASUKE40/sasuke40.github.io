{"componentChunkName":"component---src-templates-blog-post-js","path":"/compare-vue-composition-api-with-react-hooks/","result":{"data":{"site":{"siteMetadata":{"title":"Edward Elric's Blog"}},"markdownRemark":{"id":"dede980d-161e-522e-b3b1-94ff2753d282","excerpt":"引言 最近 Vue 3.0 发布了 Beta 版本，其中最引人注意的就是其 。而这个设计近期经常被拿来和\n 进行比较，以下是两个代码片段： 我们可以看到两者的心智模型非常不同，React 编程范式更接近于纯函数，Vue 则采取了 Reactivity 的模式。 React Hooks 的心智负担 React Hooks…","html":"<h1>引言</h1>\n<p>最近 <a href=\"https://github.com/vuejs/vue-next\">Vue 3.0</a> 发布了 Beta 版本，其中最引人注意的就是其 <code class=\"language-text\">Composition API</code>。而这个设计近期经常被拿来和\n<code class=\"language-text\">React Hooks</code> 进行比较，以下是两个代码片段：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> setA<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setA</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Vue 3 composition API</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">setA</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a<span class=\"token punctuation\">.</span>value<span class=\"token operator\">++</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setA<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>我们可以看到两者的心智模型非常不同，React 编程范式更接近于纯函数，Vue 则采取了 Reactivity 的模式。</p>\n<h1>React Hooks 的心智负担</h1>\n<p>React Hooks 是在 2018 年 10 月 React Conf 的时候正式向广大开发者进行宣传，在当时看到 Dan Abramov 演讲以及现场使用 React Hooks 重构 Class Component 的时候简直惊为天人，那一刻我深深被 Function Programming 所着迷。\n然而，直到如今一年半开发者各种实践，发现 React Hooks 并没有想象中的那么美好。你现在可以在知乎、掘金等各类平台上搜寻到大量的《React Hooks 最佳实践》，这不禁让人深思：React Hooks 怎么没那么美好了？</p>\n<p>React Hooks 开发经常提及的一些问题我列举几个：</p>\n<ol>\n<li>我该使用单个 state 变量还是多个 state 变量？</li>\n<li>deps 依赖过多，导致 Hooks 难以维护？</li>\n<li>该不该使用 useMemo？</li>\n</ol>\n<p>然后基于这些问题的最佳实践，人们又总结出：</p>\n<ol>\n<li>将完全不相关的 state 拆分为多组 state。</li>\n<li>如果某些 state 是相互关联的，或者需要一起发生改变，就可以把它们合并为一组 state。</li>\n<li>依赖数组依赖的值最好不要超过 3 个，否则会导致代码会难以维护。</li>\n<li>\n<p>如果发现依赖数组依赖的值过多，我们应该采取一些方法来减少它。</p>\n<ol>\n<li>去掉不必要的依赖。</li>\n<li>将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组。</li>\n<li>通过合并相关的 state，将多个依赖值聚合为一个。</li>\n<li>通过 setState 回调函数获取最新的 state，以减少外部依赖。</li>\n<li>通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径。</li>\n</ol>\n</li>\n<li>\n<p>应该使用 useMemo 的场景：</p>\n<ol>\n<li>保持引用相等</li>\n<li>成本很高的计算</li>\n</ol>\n</li>\n<li>\n<p>无需使用 useMemo 的场景：</p>\n<ol>\n<li>如果返回的值是原始值： string, boolean, null, undefined, number, symbol（不包括动态声明的 Symbol），一般不需要使用 useMemo。</li>\n<li>仅在组件内部用到的 object、array、函数等（没有作为 props 传递给子组件），且没有用到其他 Hook 的依赖数组中，一般不需要使用 useMemo。</li>\n</ol>\n</li>\n<li>Hooks、Render Props 和高阶组件都有各自的使用场景，具体使用哪一种要看实际情况。</li>\n<li>若 Hook 类型相同，且依赖数组一致时，应该合并成一个 Hook。</li>\n<li>自定义 Hooks 的返回值可以使用 Tuple 类型，更易于在外部重命名。如果返回的值过多，则不建议使用。</li>\n<li>ref 不要直接暴露给外部使用，而是提供一个修改值的方法。</li>\n<li>在使用 useMemo 或者 useCallback 时，可以借助 ref 或者 setState callback，确保返回的函数只创建一次。也就是说，函数不会根据依赖数组的变化而二次创建。</li>\n</ol>\n<p>React Hooks 给人一种美丽的错觉，Function Component 可以非常简单，但长期开发下才逐渐暴露出函数式编程在 JavaScript 中的困境。\n对这个问题大家在思考，而 Vue 3.0 也在思考如何从 React Hooks 上取其精华去其糟粕。我们可以在 Vue RFC 中看到最初的 <a href=\"https://github.com/vuejs/rfcs/pull/17\">Class API</a> 到 <a href=\"https://github.com/vuejs/rfcs/pull/42\">Function-based Component API</a> 取其 FP 的精华，再到被修订为 <a href=\"https://github.com/vuejs/rfcs/pull/78\">Composition API</a> 采用 Reactivity 的过程。</p>\n<p>这种改变和 JavaScript 这门语言本身的编程范式离不开，主要还是围绕一等公民函数、动态类型这两点。</p>\n<h1>Vue Composition API 是否美好</h1>\n<p>Vue 一直被人所称道的就是其开发简便，这也是隐式依赖跟踪带来的便利。然而成也萧何败也萧何，Vue 诟病的一点就是闭包对象的不可预测性，例如 this。</p>\n<p>在 Vue Composition API 中，我发现官方对 Ref 和 Reactive 给出了最佳实践。可能这里就有所谓的幻灭存在，就像当年很多人不听 React 官方最佳实践，在 componentWillMount 里获取数据一样。</p>\n<p><a href=\"https://composition-api.vuejs.org/#ref-vs-reactive\">Ref vs. Reactive</a> 章节中有如下的对比：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// style 1: separate variables</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">updatePosition</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  x <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>pageX\n  y <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>pageY\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// --- compared to ---</span>\n\n<span class=\"token comment\">// style 2: single object</span>\n<span class=\"token keyword\">const</span> pos <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  y<span class=\"token operator\">:</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">updatePosition</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  pos<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>pageX\n  pos<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>pageY\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那么依赖跟踪的迷惑就此开始，因为当你对已经 reactive 的对象进行解构赋值或者赋给新值的时候，依赖跟踪就失效了。官方对这个的态度比较模糊：</p>\n<blockquote>\n<p>在现阶段，我们认为在 ref vs reactive 上实施最佳做法为时尚早。我们建议您从上面的两个选项中选择与您的心智模型相符的方式。我们将收集实开发场景下的用户真反馈，并最终提供有关此主题的更明确的指导。</p>\n</blockquote>\n<h1>对比两者</h1>\n<ul>\n<li>Vue Composition API：闭包变量、响应式的依赖追踪</li>\n<li>React Hooks: 纯函数、无副作用</li>\n</ul>\n<p>其实没有好坏之分，在 JavaScript 这种编程范式模棱两可的语言中，你既可以写函数，但又不能不让改引用变量（像 cpp 的 const&#x26; 一般），你又可以面向对象编程（像 Java 一样疯狂反射，咻咻咻）。</p>\n<p>其实语言、框架没有优劣，主要看使用的人对其理解到什么程度。使用 React Hooks 就要尽量采用 immutable 变量，降低函数调用过频影响性能（部分 React 调度策略兜底）；使用 Vue 就尽量不要依赖跟踪丢失或者滥用依赖跟踪导致行为不可预测。</p>\n<h1>最后</h1>\n<p>React 和 Vue 没有不可调和之处，他们是 JavaScript 这门语言一体两面的提现。</p>\n<p>未来哪个社区更加繁荣还是要看 TC39 把 JavaScript 带向何方，是更加 Functional Programming 呢？还是更加 Imperative Programming 呢？</p>","frontmatter":{"title":"对比 Vue Composition API 和 React Hooks","date":"2020-05-10T00:00:00.000Z"}}},"pageContext":{"slug":"/compare-vue-composition-api-with-react-hooks/","previous":{"fields":{"slug":"/a-guide-to-building-a-personal-website-with-gatsby/"},"frontmatter":{"title":"使用 Gatsby 搭建个人网站指南"}},"next":{"fields":{"slug":"/recoil-a-state-management-system-for-react/"},"frontmatter":{"title":"Recoil 一个基于 actor 模型的 React 状态管理库"}}}}}