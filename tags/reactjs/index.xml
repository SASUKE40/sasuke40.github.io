<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reactjs on Shilin's Blog</title><link>https://edward40.com/tags/reactjs/</link><description>Recent content in Reactjs on Shilin's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 16 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://edward40.com/tags/reactjs/index.xml" rel="self" type="application/rss+xml"/><item><title>Recoil 一个基于 actor 模型的 React 状态管理库</title><link>https://edward40.com/p/recoil-a-state-management-system-for-react/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://edward40.com/p/recoil-a-state-management-system-for-react/</guid><description>&lt;img src="https://edward40.com/p/recoil-a-state-management-system-for-react/Recoil%20at%20React%20Europe%202020%2000-07-24%20.png" alt="Featured image of post Recoil 一个基于 actor 模型的 React 状态管理库" /&gt;&lt;h1 id="前言"&gt;前言
&lt;/h1&gt;&lt;p&gt;最近在 React Europe 2020 Conference 上， facebook 内部释出一个状态管理库 &lt;a class="link" href="https://recoiljs.org/" target="_blank" rel="noopener"
&gt;Recoil&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过官方的宣传以及初步的使用，Recoil 在处理 shared state 上比较方便，也能做到最小度的更新来提升复杂 App 的性能。不过有趣的是，对 Recoil 的 &lt;code&gt;atom&lt;/code&gt; &lt;code&gt;selector&lt;/code&gt; 这些 API 设计而言，其实就是早在 47 年提出的 &lt;strong&gt;Actor Model&lt;/strong&gt;，可谓是前端状态管理的文艺复兴。&lt;/p&gt;
&lt;h1 id="actor-model-部分"&gt;Actor Model 部分
&lt;/h1&gt;&lt;h2 id="什么是-actor-model"&gt;什么是 Actor Model
&lt;/h2&gt;&lt;p&gt;Actor 模型(Actor model)首先是由 Carl Hewitt 在 1973 定义， 由 Erlang OTP(Open Telecom Platform) 推广，其消息传递更加符合面向对象的原始意图。Actors 属于并发组件模型，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。&lt;/p&gt;
&lt;p&gt;流行语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors 使用消息模型，每个 Actors 在同一时间处理最多一个消息，可以发送消息给其他 Actors，保证了单独写原则。从而巧妙避免了多线程写争夺。&lt;/p&gt;
&lt;p&gt;Actor Model 主要有几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量：Actor 是系统内的一个基础单位，每个 Actor 只负责自己的工作&lt;/li&gt;
&lt;li&gt;没有 Shared State：每个 Actor 各自管理自己的 state，跑在各自的 thread 上，不共享内存和 state&lt;/li&gt;
&lt;li&gt;通过消息传递：每个 Actor 有一个消息队列，类似 MailBox / Queue，接受到的消息会在此队列等待依次执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="谁使用-actor-model"&gt;谁使用 Actor Model
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Erlang&lt;/li&gt;
&lt;li&gt;Akka&lt;/li&gt;
&lt;li&gt;Vert.x&lt;/li&gt;
&lt;li&gt;Actix&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="recoil-部分"&gt;Recoil 部分
&lt;/h1&gt;&lt;h2 id="recoil-产生背景"&gt;Recoil 产生背景
&lt;/h2&gt;&lt;p&gt;前端的应用越来越复杂，诸如常见的 Web 监控面板，包含各类的性能数据、节点信息、分类聚合用来进行应用分析。可以想象得到面板中包含各类的交互行为，编辑、删除、添加、将一个数据源绑定多个面板等等。除此之外，还需要对数据持久化，这样就能把 url 分享给其他人，并要确保被分享的人看到的是一致的。&lt;/p&gt;
&lt;p&gt;因此开发过程中要尽量做到页面最小化更新达到高性能的目的，需要对数据流的操作更加精细。&lt;/p&gt;
&lt;p&gt;![](Recoil at React Europe 2020 00-00-12 .jpg)&lt;/p&gt;
&lt;p&gt;面对这样的挑战，一般会想到用一些状态管理的函数或者库，如 React 内置的 state 管理，或者 Redux。&lt;/p&gt;
&lt;p&gt;Recoil 想通过一个不一样的方式来解决这些问题，主要分为 3 个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flexible shared state: 在 react tree 任意的地方都能灵活共享 state，并保持高性能&lt;/li&gt;
&lt;li&gt;Derived data and queries: 高效可靠地根据变化的 state 进行计算&lt;/li&gt;
&lt;li&gt;App-wide state observation: time travel debugging, 支持 undo, 日志持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Recoil 主要设计&lt;/p&gt;
&lt;h3 id="shared-state"&gt;Shared state
&lt;/h3&gt;&lt;p&gt;有一个应用基于这样一个场景，将 List 中更新一个节点，然后对应 Canvas 中的节点也更新&lt;/p&gt;
&lt;p&gt;![](Recoil at React Europe 2020 00-04-55 .png)&lt;/p&gt;
&lt;h4 id="第-1-种方式"&gt;第 1 种方式
&lt;/h4&gt;&lt;p&gt;把 state 传到公共的父节点转发给 canvas 子节点，这样显然会全量 re-render&lt;/p&gt;
&lt;h4 id="第-2-种方式"&gt;第 2 种方式
&lt;/h4&gt;&lt;p&gt;给父节点加 Provider 在子节点加 Consumer，不过每多加一个 item 就要多一层 Provider&lt;/p&gt;
&lt;p&gt;![](Recoil at React Europe 2020 00-06-43 .png)&lt;/p&gt;
&lt;h4 id="第-3-种方式"&gt;第 3 种方式
&lt;/h4&gt;&lt;p&gt;在 react tree 上创建另一个正交的 tree，把每片 item 的 state 抽出来。每个 component 都有对应单独的一片 state，当数据更新的时候对应的组件也会更新。Recoil 把 这每一片的数据称为 Atom，Atom 是可订阅可变的 state 单元。&lt;/p&gt;
&lt;p&gt;![](Recoil at React Europe 2020 00-07-24 .png)&lt;/p&gt;
&lt;p&gt;配合 &lt;code&gt;useRecoilState&lt;/code&gt; 可以使用这些 Atom，实践上对多个 item 的 Atom 可以用 memorize 进行优化，具体可以在官方文档查看，这里不赘述。&lt;/p&gt;
&lt;h3 id="derived-data"&gt;Derived Data
&lt;/h3&gt;&lt;p&gt;有这么一个场景需要根据多个 Item Box 计算 Bounding Box&lt;/p&gt;
&lt;p&gt;&lt;img src="https://edward40.com/p/recoil-a-state-management-system-for-react/derived_data.png"
width="581"
height="297"
srcset="https://edward40.com/p/recoil-a-state-management-system-for-react/derived_data_hu_269ae0c5846a3eff.png 480w, https://edward40.com/p/recoil-a-state-management-system-for-react/derived_data_hu_abc944180012f5d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="195"
data-flex-basis="469px"
&gt;&lt;/p&gt;
&lt;p&gt;如果你是 Vue 的爱好者，你可能想到了计算属性。Derived Data 确实有 computed props 的味道，具体思路是选取多个 Atom 进行计算，然后返回一个新的 state。因此在 Recoil 中设计了 &lt;code&gt;select&lt;/code&gt; 这样的 API 来选取多个 Atom 进行计算。&lt;/p&gt;
&lt;p&gt;![](Recoil at React Europe 2020 00-14-53 .png)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt; 的设计和 Proxy 挺像的，属性上有 &lt;code&gt;get&lt;/code&gt; 进行读取，有 &lt;code&gt;set&lt;/code&gt; 进行设置，函数内部又有 &lt;code&gt;get&lt;/code&gt;， &lt;code&gt;set&lt;/code&gt; 操作 state&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-js" data-lang="js"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;import&lt;/span&gt; { &lt;span style="color:#a6e22e"&gt;atom&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;selector&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;useRecoilState&lt;/span&gt; } &lt;span style="color:#a6e22e"&gt;from&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;recoil&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;tempFahrenheit&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;atom&lt;/span&gt;({
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;key&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;tempFahrenheit&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;default&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;tempCelcius&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;selector&lt;/span&gt;({
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;key&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;tempCelcius&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;get&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; ({ &lt;span style="color:#a6e22e"&gt;get&lt;/span&gt; }) =&amp;gt; ((&lt;span style="color:#a6e22e"&gt;get&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;tempFahrenheit&lt;/span&gt;) &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;32&lt;/span&gt;) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;9&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;set&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; ({ &lt;span style="color:#a6e22e"&gt;set&lt;/span&gt; }, &lt;span style="color:#a6e22e"&gt;newValue&lt;/span&gt;) =&amp;gt; &lt;span style="color:#a6e22e"&gt;set&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;tempFahrenheit&lt;/span&gt;, (&lt;span style="color:#a6e22e"&gt;newValue&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;9&lt;/span&gt;) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;5&lt;/span&gt; &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;32&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="app-wide-observation"&gt;App-wide observation
&lt;/h3&gt;&lt;p&gt;这个场景下需要把 url 分享给其他人，别人打开相同的链接也能看到一样的页面。&lt;/p&gt;
&lt;p&gt;那么就需要 observe Atom 的变更，Recoil 使用 &lt;code&gt;useTransactionObservation&lt;/code&gt; 进行订阅&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-js" data-lang="js"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;useTransactionObservation&lt;/span&gt;(({&lt;span style="color:#a6e22e"&gt;atomValues&lt;/span&gt;,&lt;span style="color:#a6e22e"&gt;modifiedAtoms&lt;/span&gt;,...} =&amp;gt; {}))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一方面，打开链接的时候也需要对输入的数据进行校验&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-js" data-lang="js"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;counter&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;atom&lt;/span&gt;({
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;key&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;myCounter&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;default&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;validator&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; (&lt;span style="color:#a6e22e"&gt;untrustedInput&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;metadata&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;##Recoil 后续&lt;/p&gt;
&lt;p&gt;目前 Recoil 还属于实验阶段，不过能确定的是 Recoil 会兼容 React Concurrent Mode&lt;/p&gt;
&lt;h1 id="actor-model--recoil-联系"&gt;Actor Model &amp;amp; Recoil 联系
&lt;/h1&gt;&lt;p&gt;通过前面提及 Recoil 的设计，可以发现两者的理念是相似的。&lt;/p&gt;
&lt;p&gt;在实现的细节中 Recoil 维护了新的队列，并通过订阅、派发的机制完成消息的传递及组件的更新。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-js" data-lang="js"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// Fire or enqueue callbacks to rerender components that are subscribed to
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// nodes affected by the updatedNodes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;fireNodeSubscriptions&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;store&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Store&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;updatedNodes&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;$ReadOnlySet&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;NodeKey&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;when&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;enqueue&amp;#39;&lt;/span&gt; &lt;span style="color:#f92672"&gt;|&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;now&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt; This is called in two conditions: When an atom is set (with &amp;#39;enqueue&amp;#39;) and
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt; when an async selector resolves (with &amp;#39;now&amp;#39;). When an atom is set, we want
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt; to use the latest dependencies that may have become dependencies due to
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt; earlier changes in a batch. But if an async selector happens to resolve during
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt; a batch, it should use the currently rendered output, and then the end of the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt; batch will trigger any further subscriptions due to new deps in the new state.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;state&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;when&lt;/span&gt; &lt;span style="color:#f92672"&gt;===&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;enqueue&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;?&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;store&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getState&lt;/span&gt;().&lt;span style="color:#a6e22e"&gt;nextTree&lt;/span&gt; &lt;span style="color:#f92672"&gt;??&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;store&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getState&lt;/span&gt;().&lt;span style="color:#a6e22e"&gt;currentTree&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;store&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getState&lt;/span&gt;().&lt;span style="color:#a6e22e"&gt;currentTree&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dependentNodes&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;getDownstreamNodes&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;state&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;updatedNodes&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; (&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;key&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;of&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;dependentNodes&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ;(&lt;span style="color:#a6e22e"&gt;state&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;nodeToComponentSubscriptions&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;get&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;key&lt;/span&gt;) &lt;span style="color:#f92672"&gt;??&lt;/span&gt; []).&lt;span style="color:#a6e22e"&gt;forEach&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ([&lt;span style="color:#a6e22e"&gt;debugName&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;cb&lt;/span&gt;]) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;when&lt;/span&gt; &lt;span style="color:#f92672"&gt;===&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;enqueue&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;?&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;store&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getState&lt;/span&gt;().&lt;span style="color:#a6e22e"&gt;queuedComponentCallbacks&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;push&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;cb&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;cb&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;state&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; )
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Wake all suspended components so the right one(s) can try to re-render.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// We need to wake up components not just when some asynchronous selector
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// resolved (when === &amp;#39;now&amp;#39;), but also when changing synchronous values because
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// they may cause a selector to change from asynchronous to synchronous, in
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// which case there would be no follow-up asynchronous resolution to wake us up.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// TODO OPTIMIZATION Only wake up related downstream components
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Tracing&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;trace&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#e6db74"&gt;&amp;#39;value became available, waking components&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Array.&lt;span style="color:#a6e22e"&gt;from&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;updatedNodes&lt;/span&gt;).&lt;span style="color:#a6e22e"&gt;join&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#39;, &amp;#39;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; () =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;resolvers&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;store&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;getState&lt;/span&gt;().&lt;span style="color:#a6e22e"&gt;suspendedComponentResolvers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;resolvers&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;forEach&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;r&lt;/span&gt; =&amp;gt; &lt;span style="color:#a6e22e"&gt;r&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;resolvers&lt;/span&gt;.&lt;span style="color:#a6e22e"&gt;clear&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; )
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实 Recoil 不是 Actor Model 在前端的首次实践，2 年前 PolymerLabs 就有 &lt;a class="link" href="https://github.com/PolymerLabs/actor-helpers" target="_blank" rel="noopener"
&gt;actor-helpers&lt;/a&gt; 以及 &lt;a class="link" href="https://github.com/PolymerLabs/actor-boilerplate" target="_blank" rel="noopener"
&gt;actor-boilerplate&lt;/a&gt; 相关的实践。不过在 React 强大的生态以及 React Hooks 的加持之下，用 Sync 的方式做到异步 state 管理和共享，同时保持交互流程、高性能的 Recoil 算是补充了一个不错的方案。&lt;/p&gt;
&lt;h1 id="补充"&gt;补充
&lt;/h1&gt;&lt;p&gt;Recoil 刚刚释出实验版本，我想正好可以在不断更改的过程中了解前端 Actor Model 的实现方式步骤。&lt;/p&gt;
&lt;p&gt;另外，其实不少人批评前端的发展就是到处借鉴，没有新的事物，像是 WPF 就有很多前端可以借鉴的地方（确实也如此）。&lt;/p&gt;
&lt;p&gt;不过在我看来，放到一个比较长的时期里，前端慢慢吸收各类后端、客户端的设计思想才产生“新”事物是很正常的发展进程。包括经常被提到的 Vue 和 React 孰优孰劣之争，Node.js 不堪大用等等话题，其实都是历史发展及其技术定位所致。可能对其他领域的看来是不新鲜，但对前端而言是语言发展（残疾而缝合的 JavaScript）、生态繁荣才有可能繁衍出这些对前端而言的新事物。&lt;/p&gt;</description></item></channel></rss>